type struct = number | string;

/**遍历函数
 */
interface EachCallback<T> {
    /**
     * @param {T} value         - 值
     * @param {number} index    - 下标
     * @param {SList<T>} list   - 数组
     * @returns {void}
     */
    (value: T, index: number, list: SList<T>): void;
}

/**加工函数
 */
interface MapCallback<T, U> {
    /**
     * @param {T} value         - 值
     * @param {number} index    - 下标
     * @param {SList<T>} list   - 数组
     * @returns {U}             - 返回值
     */
    (value: T, index: number, list: SList<T>): U;
}

/**过滤函数
 */
interface FiltCallback<T> {
    /**
     * @param {T} value         - 值
     * @param {number} index    - 下标
     * @param {SList<T>} list   - 数组
     * @returns {boolean}       - 返回值
     */
    (value: T, index: number, list: SList<T>): boolean;
}

/**统计函数
 */
interface AggrCallback<T, U> {
    /**
     * @param {U} accumulator   - 累加器
     * @param {T} value         - 值
     * @param {number} index    - 下标
     * @param {SList<T>} list   - 数组
     * @returns {U}             - 返回值
     */
    (accumulator: U, value: T, index: number, list: SList<T>): U;
}

/**缩减函数
 */
interface ReduceCallback<T> {
    /**
     * @param {T} previousValue     - 上一个值/累加值
     * @param {T} currentValue      - 当前值
     * @param {number} currentIndex - 当前下标
     * @param {SList<T>} list       - 数组
     * @returns {T}                 - 返回值
     */
    (
        previousValue: T,
        currentValue: T,
        currentIndex: number,
        list: SList<T>
    ): T;
}

/**排序函数
 */
interface SortCallback<T> {
    /**
     * @param {T} a         - 值a
     * @param {T} b         - 值b
     * @returns {number}    - 返回值
     */
    (a: T, b: T): number;
}

export class SList<T> {
    private _arr: Array<T>;
    /**建立0长度的SList */
    constructor();
    /**建立一个长度为 obj 的SList */
    constructor(obj:number);
    /**根据obj建立SList */
    constructor(obj:Array<T>);
    constructor(obj?: Array<T> | number) {
        if (typeof obj == "number") this._arr = new Array<T>(obj);
        else if (Array.isArray(obj)) this._arr = obj;
        else this._arr = [];
    }
    /**返回数组长度
     * @returns {number} - 长度
     */
    size(): number {
        return this._arr.length;
    }

    /**获取指定下标的元素
     * @param {number} index - 下标
     * @returns {T} - 目标元素
     */
    get(index: number): T {
        return this._arr[index];
    }

    /**设置指定下标的元素
     * 返回自身 改变自身
     * @param   {number} index  - 下标
     * @param   {T} value       - 值
     * @returns {SList<T>}      - 自身
     */
    set(index: number, value: T): SList<T> {
        this._arr[index] = value;
        return this;
    }

    /**连接两个数组
     * @param   {SList<T>} list - 目标数组
     * @returns {SList<T>}      - 新数组
     */
    concat(list: SList<T>): SList<T> {
        return new SList<T>(this._arr.concat(list._arr));
    }

    /**在数组末尾添加一个元素
     * 返回自身 改变自身
     * @param   {T} value   - 值
     * @returns {SList<T>}  - 自身
     */
    push(value: T): SList<T> {
        this._arr.push(value);
        return this;
    }

    /**在数组末尾添加一个数组
     * 改变自身
     * @param   {SList<T>} list - 目标数组
     * @returns {SList<T>}      - 自身
     */
    pushList(list: SList<T>) {
        this._arr = this._arr.concat(list._arr);
        return this;
    }

    /**截取从起始点到结束点之前的一段数组
     * @param   {number} strat - 起始点
     * @param   {number} end   - 结束点
     * @returns {SList<T>}     - 新数组
     */
    slice(strat: number, end: number): SList<T> {
        return new SList(this._arr.slice(strat, end));
    }

    /**翻转数组
     * 改变自身
     * @returns {SList<T>} - 自身
     */
    reverse(): SList<T> {
        this._arr.reverse();
        return this;
    }

    /**将SList转换为数组
     * @returns {Array<T>} - 数组
     */
    toArray(): Array<T> {
        return ([] as T[]).concat(this._arr);
    }

    /**将SList转换为SStream
     * @param   {number} concurrent - 并发数
     * @returns {SStream<T>} - 流
     */
    toSStream(concurrent?: number): SStream<T> {
        return new SStream<T>(this._arr, concurrent);
    }

    /**返回指定元素在数组中首次出现的位置
     * @param   {T} value   - 目标元素
     * @returns {number}    - 下标
     */
    indexOf(value: T): number {
        return this._arr.indexOf(value);
    }

    /**返回指定元素在数组中最后一次出现的位置
     * @param   {T} value   - 目标元素
     * @returns {number}    - 下标
     */
    lastIndexOf(value: T): number {
        return this._arr.lastIndexOf(value);
    }

    /**判断数组中是否包含指定元素
     * @param   {T} value    - 目标元素
     * @returns {boolean}    - 是否包含
     */
    contains(value: T): boolean {
        return this._arr.includes(value);
    }

    /**获取迭代器
     * @returns {SIterator<T>} - 迭代器
     */
    iterator(): SIterator<T> {
        return new SIterator<T>(this);
    }

    /**平分数组
     * @param   {number} count              - 份数
     * @param   {"average" | "chunk"} mode  - 模式 average:轮询平均分 chunk:切块均分
     * @returns {SList<SList<T>>}           - 新数组
     */
    divide(
        count: number,
        mode: "average" | "chunk" = "average"
    ): SList<SList<T>> {
        if (count <= 0) return new SList<SList<T>>();
        if (count == 1) return new SList<SList<T>>([this.clone()]);

        let result = new SList<SList<T>>();
        switch (mode) {
            //轮询平均分
            default:
            case "average":
                for (let i = 0; i < count; i++) {
                    let clist = new SList<T>();
                    let size = this.size();
                    for (let j = i; j < size; j += count)
                        clist.push(this.get(j));
                    result.push(clist);
                }
                break;
            //切块均分
            case "chunk":
                let chunkSize = Math.ceil(this.size() / count);
                for (let i = 0; i < count; i++) {
                    let start = i * chunkSize;
                    let end = (i + 1) * chunkSize;
                    if (end > this.size()) end = this.size();
                    result.push(this.slice(start, end));
                }
                break;
        }
        return result;
    }

    /**从index开始删除count个元素，返回删除的元素数组
     * 改变自身
     * @param   {number} index  - 起始点
     * @param   {number} count  - 数量
     * @returns {SList<T>}      - 删除的元素数组
     */
    removeRange(index: number, count: number): SList<T> {
        let narr = this._arr.splice(index, count);
        return new SList<T>(narr);
    }

    /**删除对应下标下的元素，返回删除的元素
     * 改变自身
     * @param   {number} i   - 下标
     * @returns {T|null}     - 删除的元素
     */
    remove(i: number): T|null {
        if (i >= 0 && i < this.size())
            return this._arr.splice(i, 1)[0];
        return null;
    }

    /**删除第一个匹配的项目，返回自身
     * 改变自身
     * @param   {T} obj     - 需删除目标
     * @returns {SList<T>}  - 自身
     */
    removeMember(obj: T): SList<T> {
        let index = this.indexOf(obj);
        if (index > -1) this.remove(index);
        return this;
    }

    /**删除所有匹配的项目
     * 改变自身
     * @param {T} obj - 需删除目标
     * @returns {SList<T>} - 自身
     */
    removeAllMember(obj: T): SList<T> {
        while (this.contains(obj)) this.removeMember(obj);
        return this;
    }
    /**在这个下标对应的元素前添加一个元素
     * 改变自身
     * @param {number} index - 下标
     * @param {T} obj - 添加对象
     * @returns {SList<T>} - 自身
     */
    insert(index: number, obj: T): SList<T> {
        this._arr.splice(index, 0, obj);
        return this;
    }

    /**在这个下标对应的元素前添加一组元素
     * 改变自身
     * @param {number} index - 下标
     * @param {SList<T>} obj - 添加对象
     * @returns {SList<T>} - 自身
     */
    insertRange(index: number, obj: SList<T>): SList<T> {
        this._arr.splice(index, 0, ...obj._arr);
        return this;
    }

    /**删除并返回最后一个元素
     * 改变自身
     * @returns {T | null} - 最后一个元素
     */
    pop(): T | null {
        let val = this._arr.pop();
        return val == undefined ? null : val;
    }

    /**删除并返回第一个元素
     * 改变自身
     * @returns {T | null} - 第一个元素
     */
    shift(): T | null {
        let val = this._arr.shift();
        return val == undefined ? null : val;
    }



    /**克隆数组
     * @returns {SList<T>} - 新数组
     */
    clone(): SList<T> {
        return new SList(([] as T[]).concat(this._arr));
    }

    /**判断数组是否为空
     * @returns {boolean} - 是否为空
     */
    isEmpty(): boolean {
        return this.size() == 0;
    }

    /**删除数组中的重复元素
     * 改变自身
     * @returns {SList<T>} - 自身
     */
    removeDuplicates(): SList<T> {
        this._arr = Array.from(new Set(this._arr));
        return this;
    }

    /**交集
     * @param {SList<T>[]} lists - 数组列表
     * @returns {SList<T>} - 新数组
     */
    intersection(...lists: SList<T>[]): SList<T> {
        let nlist = this.clone().removeDuplicates();

        for (let list of lists) nlist = list.filt((val) => nlist.contains(val));

        return nlist;
    }
    /**并集
     * @param {SList<T>[]} lists - 数组列表
     * @returns {SList<T>} - 新数组
     */
    union(...lists: SList<T>[]): SList<T> {
        let nlist = this.clone().removeDuplicates();

        for (let list of lists) {
            list.each((val) => {
                if (!nlist.contains(val)) nlist.push(val);
            });
        }

        return nlist;
    }

    /**返回符合条件的成员组成的新数组
     * @param {FiltCallback<T>} func - 条件函数
     * @returns {SList<T>} - 新数组
     */
    filt(func: FiltCallback<T>): SList<T> {
        let nlist = new SList<T>(this.size());
        let length = 0;
        let it = this.iterator();
        while (it.hasNext()) {
            let tmpObj = it.next();
            if (func(tmpObj, it.currIndex(), this)) {
                nlist.set(length, tmpObj);
                length++;
            }
        }
        return nlist.slice(0, length);
    }

    /**遍历数组的每一个元素
     * @param {EachCallback<T>} func - 遍历函数 (value: T, index: number, list: SList<T>): void
     * @returns {SList<T>} - 自身
     */
    each(func: EachCallback<T>): SList<T> {
        let it = this.iterator();
        while (it.hasNext()) func(it.next(), it.currIndex(), this);
        return this;
    }

    /**对数组的每一个元素进行加工，返回加工完成的成员组成的新数组
     * @param {MapCallback<T,O>} func - 加工函数 (value: T, index: number, list: SList<T>): O
     * @returns {SList<O>} - 新数组
     */
    map<O>(func: MapCallback<T, O>): SList<O> {
        let nlist = new SList<O>(this.size());
        let it = this.iterator();
        while (it.hasNext())
            nlist.set(it.nextIndex(), func(it.next(), it.currIndex(), this));
        return nlist;
    }

    /**对数组进行排序
     * 如函数返回值大于 0 则将 x 排在 y 后面，小于 0 则将 x 排在 y 前面
     * 改变自身
     * @param {SortCallback<T>} func - 排序函数 (a: T, b: T): number
     * @returns {SList<T>} - 自身
     */
    sort(func: SortCallback<T>): SList<T> {
        this._arr.sort(func);
        return this;
    }
    /**对数组进行统计 aggregate
     * 遍历数组，并将每次遍历的结果与下一次遍历的元素一起传入函数，最后返回最后一次遍历的结果
     * @param   {O} init                 - 初始值
     * @param   {AggrCallback<T,O>} func - 统计函数 (value: T, accumulator: U, index: number, list: SList<T>): U
     * @returns {O}                      - 统计结果
     */
    public aggr<O>(init: O, func: AggrCallback<T, O>): O {
        let it = this.iterator();
        let tmpObj = init;
        while (it.hasNext())
            tmpObj = func(tmpObj, it.next(), it.currIndex(), this);
        return tmpObj;
    }

    /**对数组进行缩减
     * 遍历数组，并将每次遍历的结果与下一次遍历的元素一起传入函数，最后返回最后一次遍历的结果
     * @param   {ReduceCallback<T>} func  - 缩减函数 (previousValue: T, currentValue: T, currentIndex: number, array: SList<T>):T
     * @param   {T} init                  - 初始值
     * @returns {T}                       - 缩减结果
     */
    public reduce(func: ReduceCallback<T>, init?: T): T | null {
        if (this.size() === 0) return null;
        let it = this.iterator();
        let tmpObj = init === undefined ? it.next() : init;
        while (it.hasNext())
            tmpObj = func(tmpObj, it.next(), it.currIndex(), this);
        return tmpObj;
    }

    //重载TypeScript操作符
    [Symbol.iterator]() {
        let it = this.iterator();

        return {
            next(): { value: T | null; done: boolean } {
                if (it.hasNext()) {
                    return { value: it.next(), done: false };
                } else {
                    return { value: null, done: true };
                }
            },
        };
    }
}

interface SStreamOperation<T, U> {
    (item: T): Promise<U>;
}
export class SStream<T> {
    /**并发数*/
    private _concurrent: number;
    /**原始列表*/
    private _slist: SList<T>;
    /**加工函数列表*/
    private _operation: Array<SStreamOperation<T, T>> = [];
    constructor(slist: SList<T> | Array<T>, concurrent: number = 1) {
        if (slist instanceof SList) this._slist = slist;
        else if (Array.isArray(slist)) this._slist = new SList(slist);
        else this._slist = new SList();
        this._concurrent = concurrent;
    }

    /**映射加工
     * @param {SStreamOperation<T,U>} operation - 加工函数
     * @returns {SStream<U>} - 新流
     */
    map<U>(operation: SStreamOperation<T, U>): SStream<U> {
        this._operation.push(operation as any);
        return this as any as SStream<U>;
    }
    /**遍历
     * 返回自身
     * @param {SStreamOperation<T,void>} operation - 遍历函数
     * @returns {SStream<T>} - 自身
     */
    each(operation: SStreamOperation<T, void>): SStream<T> {
        let opera = async (item: T) => {
            operation(item);
            return item;
        };
        this._operation.push(opera);
        return this;
    }

    //终结操作
    /**应用加工
     * @returns {SStream<T>} - 自身
     */
    async appendOperations(): Promise<SStream<T>> {
        if (this._operation.length == 0) return this;

        let nlist = new SList<SList<T>>();
        let promiseList: Array<Promise<any>> = [];
        //均分处理
        let sliceList = this._slist.divide(this._concurrent);
        for (let i = 0; i < this._concurrent; i++) {
            let subList = sliceList.get(i);
            if (!subList) continue;
            promiseList.push(
                new Promise(async () => {
                    let result = new SList<T>();
                    for (let item of subList) {
                        if (!item) continue;
                        for (let operation of this._operation)
                            item = await operation(item);
                        result.push(item);
                    }
                    nlist.set(i, result);
                })
            );
        }
        await Promise.all(promiseList);
        //拼接结果 轮询均分
        let result = new SList<T>(this._slist.size());
        for (let i = 0; i < this._concurrent; i++) {
            let subList = nlist.get(i);
            if (!subList) continue;
            let subSize = subList.size();
            for (let j = 0; j < subSize; j++)
                result.set(i + j * this._concurrent, subList.get(j));
        }
        this._slist = result;
        this._operation = [];
        return this;
    }
    /**转换为SList
     * @returns {SList<T>} - 数组
     */
    async toSList(): Promise<SList<T>> {
        await this.appendOperations();
        return this._slist;
    }
    /**转换为数组
     * @returns {Array<T>} - 数组
     */
    async toArray(): Promise<Array<T>> {
        await this.appendOperations();
        return this._slist.toArray();
    }
}

export class SIterator<T> {
    private _index = -1;
    private _list: SList<T>;
    constructor(list: SList<T>) {
        this._list = list;
    }
    /**判断还有没有下一个元素
     * @returns {boolean} - 是否有下一个元素
     */
    hasNext(): boolean {
        return this._index < this.size() - 1 && this._index >= -1;
    }

    /**判断当前下标有无元素
     * @returns {boolean} - 是否有当前元素
     */
    hasCurr(): boolean {
        return this._index < this.size() && this._index >= 0;
    }

    /**判断还有没有上一个元素
     * @returns {boolean} - 是否有上一个元素
     */
    hasPre(): boolean {
        return this._index < this.size() + 1 && this._index >= 1;
    }

    /**返回下一个下标指向的数组内成员,然后下标自加1
     * @returns {T} - 下一个成员
     */
    next(): T {
        if (this.hasNext()) return this._list.get(++this._index);
        else
            throw "一个 SIterator 迭代器的 next 函数出错,可能是在下标到底时还在尝试迭代";
    }

    /**返回上一个下标指向的数组内成员,然后下标自减1
     * @returns {T} - 上一个成员
     */
    pre(): T {
        if (this.hasPre()) return this._list.get(--this._index);
        else
            throw "一个 SIterator 迭代器的 pre 函数出错,可能是在下标小于1时还在尝试迭代";
    }

    /**返回当前下标指向的数组内成员
     * @returns {T} - 当前成员
     */
    curr(): T {
        if (this.hasCurr()) return this._list.get(this._index);
        else
            throw "一个 SIterator 迭代器的 curr 函数出错,可能是当前下标不包含元素/当前下标已越界";
    }

    /**返回遍历长度
     * @returns {number} - 遍历长度
     */
    size(): number {
        return this._list.size();
    }

    /**获取下个下标
     * @returns {number} - 下个下标
     */
    nextIndex(): number {
        return this._index + 1;
    }

    /**获取当前下标
     * @return {number} - 当前下标
     */
    currIndex(): number {
        return this._index;
    }

    /**获取上个下标
     * @returns {number} - 上个下标
     */
    preIndex(): number {
        return this._index - 1;
    }

    /**判断是否是最后一个
     * @returns {boolean} - 是否是最后一个
     */
    isLast(): boolean {
        return this._index >= this._list.size() - 1;
    }

    /**设置数组在迭代器当前下标中的内容
     * 返回自身
     * @param {T} val 要设置的内容
     * @returns {void}
     */
    set(val: T): SIterator<T> {
        this._list.set(this._index, val);
        return this;
    }

    /**删除数组在当前下标的内容，然后将下标移至上一位，改变数组长度
     * @returns {T} - 被删除的内容
     */
    remove(): T {
        let tmp = this._list.get(this._index);
        this._list.remove(this._index);
        this._index--;
        return tmp;
    }

    /**在当前下标前插入元素，然后将下标移至原元素，即下一位，改变数组长度
     * 返回自身
     * @param {T} obj - 要插入的元素
     * @returns {SIterator<T>} - 自身
     */
    addPre(obj: T): SIterator<T> {
        this._list.insert(this._index, obj);
        this._index++;
        return this;
    }

    /**在当前下标后插入元素，然后将下标移至新元素，即下一位，改变数组长度
     * 返回自身
     * @param {T} obj - 要插入的元素
     * @returns {SIterator<T>} - 自身
     */
    addNext(obj: T): SIterator<T> {
        this._list.insert(this._index + 1, obj);
        this._index++;
        return this;
    }
}

export class SEntry<K, V> {
    private _key: K;
    private _value: V;

    constructor(key: K, value: V) {
        this._key = key;
        this._value = value;
    }
    getKey() {
        return this._key;
    }
    getValue() {
        return this._value;
    }

    //重载TypeScript操作符
    get key(): K {
        return this.getKey();
    }

    get value(): V {
        return this._value;
    }
}
export class SHashMap<K, V> {
    private _map: Map<K, V> = new Map();

    /**构造函数
     * @param {Map<K, V>} [map] - 一个键值对集合
     */
    constructor(map?: Map<K, V>) {
        if (map == null) return;
        let keys = map.keys();
        for (let key of keys) {
            let value = map.get(key);
            if (value != null) this.put(key, value);
        }
    }
    /**添加一个键值对
     * 返回自身
     * @param {SEntry<K, V>} entry - 键值对
     * @returns {SHashMap<K, V>} - 自身
     */
    putEntry(entry: SEntry<K, V>): SHashMap<K, V> {
        this._map.set(entry.getKey(), entry.getValue());
        return this;
    }

    /**获取指定键的值
     * @param {K} key - 键
     * @returns {V | undefined} - 值
     */
    get(key: K): V | undefined {
        return this._map.get(key);
    }

    /**添加一个键值对
     * 返回自身
     * @param {K} key - 键
     * @param {V} value - 值
     * @returns {SHashMap<K, V>} - 自身
     */
    put(key: K, value: V): SHashMap<K, V> {
        this._map.set(key, value);
        return this;
    }

    /**判断是否存在指定键
     * @param {K} key - 键
     * @returns {boolean} - 是否存在
     */
    has(key: K): boolean {
        return this._map.has(key);
    }

    /**获取所有键值对
     * @returns {SList<SEntry<K, V>>} - 键值对列表
     */
    entrys(): SList<SEntry<K, V>> {
        let list = new SList<SEntry<K, V>>();
        for (const [key, value] of this._map) list.push(new SEntry(key, value));
        return list;
    }

    /**获取所有键
     * @returns {SList<K>} - 键列表
     */
    keys(): SList<K> {
        let list = new SList<K>();
        let it = this._map.keys();
        for (let key of it) list.push(key);
        return list;
    }

    /**获取所有值
     * @returns {SList<V>} - 值列表
     */
    values(): SList<V> {
        let list = new SList<V>();
        let it = this._map.values();
        for (let val of it) list.push(val);
        return list;
    }

    /**转换为entry数组，并获取迭代器
     * @returns {SIterator<SEntry<K, V>>} - 迭代器
     */
    iterator(): SIterator<SEntry<K, V>> {
        return this.entrys().iterator();
    }

    /**删除指定键的键值对
     * @param {K} key - 键
     * @returns {V | undefined} - 被删除的值
     */
    remove(key: K): V | undefined {
        let out = this._map.get(key);
        this._map.delete(key);
        return out;
    }

    /**清空哈希表
     * @returns {SHashMap<K, V>} - 自身
     */
    clear(): SHashMap<K, V> {
        this._map.clear();
        return this;
    }

    /**判断哈希表是否为空
     * @returns {boolean} - 是否为空
     */
    isEmpty(): boolean {
        return this.isEmpty();
    }

    /**判断是否存在指定值
     * @param {V} val - 值
     * @returns {boolean} - 是否存在
     */
    containsValue(val: V): boolean {
        return this.values().contains(val);
    }

    /**判断是否存在指定键
     * @param {K} key - 键
     * @returns {boolean} - 是否存在
     */
    containsKey(key: K): boolean {
        return this._map.has(key);
    }

    /**加载指定键的值，若不存在则添加默认值
     * 返回键值
     * @param {K} key - 键
     * @param {V} def - 默认值
     * @returns {V} - 值
     */
    load(key: K, def: V): V {
        if (this.containsKey(key)) return this.get(key)!;
        this.put(key, def);
        return def;
    }

    /**合并另一个哈希表，可选择是否覆盖已有键值对
     * @param {SHashMap<K, V>} nmap - 另一个哈希表
     * @param {boolean} [isCover=true] - 是否覆盖已有键值对，默认为 true
     * @returns {SHashMap<K, V>} - 自身
     */
    merge(nmap: SHashMap<K, V>, isCover: boolean = true): SHashMap<K, V> {
        var it = nmap.iterator();
        while (it.hasNext()) {
            if (isCover) this.putEntry(it.next());
            else {
                var entry = it.next();
                if (!this.containsKey(entry.getKey())) this.putEntry(entry);
            }
        }
        return this;
    }

    /**获取哈希表大小（键的数量）
     * @returns {number} - 大小
     */
    size(): number {
        return this._map.size;
    }
    /**对哈希表的每一个键值对进行加工，返回加工完成的键值对组成的新哈希表
     * @param {MapCallback<SEntry<K, V>, SEntry<OK, OV>>} func - 加工函数
     * @returns {SHashMap<OK, OV>} - 新哈希表
     */
    map<OK, OV>(
        func: MapCallback<SEntry<K, V>, SEntry<OK, OV>>
    ): SHashMap<OK, OV> {
        let nmap = new SHashMap<OK, OV>();
        this.entrys()
            .map(func)
            .each((val) => nmap.putEntry(val));
        return nmap;
    }

    /**返回符合条件的键值对组成的新哈希表
     * @param {FiltCallback<SEntry<K, V>>): boolean} func - 条件函数
     * @returns {SHashMap<K, V>} - 新哈希表
     */
    filt(func: FiltCallback<SEntry<K, V>>): SHashMap<K, V> {
        let nmap = new SHashMap<K, V>();
        this.entrys()
            .filt(func)
            .each((val) => nmap.putEntry(val));
        return nmap;
    }

    /**遍历哈希表的每一个键值对
     * @param {EachCallback<SEntry<K, V>>} func - 遍历函数
     * @returns {SHashMap<K, V>} - 自身
     */
    each(func: EachCallback<SEntry<K, V>>): SHashMap<K, V> {
        this.entrys().each(func);
        return this;
    }

    /**对哈希表进行统计
     * @param   {O} init                            - 初始值
     * @param   {AggrCallback<SEntry<K, V>,O>} func - 统计函数
     * @returns {O}                                 - 统计结果
     */
    aggr<O>(init: O, func: AggrCallback<SEntry<K, V>, O>): O {
        return this.entrys().aggr(init, func);
    }

    /**对哈希表进行缩减
     * @param {AggrCallback<SEntry<K, V>,V>} func   - 缩减函数
     * @param {V} init                              - 初始值
     * @returns {V}                                 - 缩减结果
     */
    reduce(func: AggrCallback<SEntry<K, V>, V>, init?: V): V | null {
        if (this.isEmpty()) {
            if (init === undefined) return null;
            return init;
        }

        let entries = this.entrys();
        let result: V;
        if (init === undefined) {
            result = entries.get(0).getValue();
            entries.shift();
        } else result = init;

        entries.each((val, index, list) => {
            result = func(result, val, index, list);
        });
        return result;
    }

    //重载TypeScript操作符
    [Symbol.iterator]() {
        let it = this.iterator();

        return {
            next(): { value: SEntry<K, V> | null; done: boolean } {
                if (it.hasNext()) {
                    return { value: it.next(), done: false };
                } else {
                    return { value: null, done: true };
                }
            },
        };
    }
}

class SKVC {
    private stringMap: SHashMap<string, string> = new SHashMap();

    constructor() {}
}
