import * as fs from "fs";
import * as path from "path";
import { JObject, JToken, stringifyJToken } from "./UtilInterfaces";
import { SLogger } from "./UtilLogger";

/**文件工具 */
export namespace UtilFT{

/**验证路径 文件或文件夹 是否存在 异步
 * @async
 * @param {string} filePath - 待验证的路径
 * @returns {Promise<boolean>} - 是否存在
 */
export async function pathExists(filePath: string):Promise<boolean>{
    try {
        const stats = await fs.promises.stat(filePath);
        await fs.promises.access(filePath);
        return true;
    } catch (e) {
        return false;
    }
}

/**验证路径 文件或文件夹 是否存在 同步
 * @param {string} filePath - 待验证的路径
 * @returns {boolean} - 是否存在
 */
export function pathExistsSync(filePath: string):boolean{
    try {
        fs.accessSync(filePath);
        return true;
    } catch (e) {
        return false;
    }
}

/**路径不存在时创建路径 以path.sep结尾时创建文件夹 异步
 * @async
 * @param {string} filePath - 待创建的路径
 * @param {boolean} isDir   - 强制创建一个文件夹
 * @returns {Promise<boolean>} - 是否成功创建
 */
export async function createPath(filePath: string, isDir?:boolean):Promise<boolean>{
    if(isDir==true)
        filePath = path.join(filePath,path.sep);

    try{
        if(filePath.endsWith(path.sep)){
            await fs.promises.mkdir(filePath, {recursive: true});
            return true;
        }
        await fs.promises.mkdir(path.dirname(filePath), {recursive: true});
        await fs.promises.open(filePath, 'w');
        return true;
    }
    catch(e){
        SLogger.error("createPath 错误",e);
        return false;
    }
}

/**路径不存在时创建路径 以path.sep结尾时创建文件夹 同步
 * @param {string} filePath - 待创建的路径
 * @param {boolean} isDir   - 强制验证一个文件夹
 * @returns {boolean} - 是否成功创建
 */
export function createPathSync(filePath: string, isDir?:boolean):boolean{
    if(isDir==true)
        filePath = path.join(filePath,path.sep);

    try{
        if(filePath.endsWith(path.sep)){
            fs.mkdirSync(filePath, {recursive: true});
            return true;
        }
        fs.mkdirSync(path.dirname(filePath), {recursive: true});
        fs.openSync(filePath, 'w');
        return true;
    }
    catch(e){
        SLogger.error("createPathSync 错误",e);
        return false;
    }
}

/**确保路径存在 不存在时创建 异步
 * @async
 * @param {string} filePath - 待验证的路径
 * @param {boolean} isDir   - 强制验证一个文件夹
 * @returns {Promise<boolean>} - 是否成功执行 创建或已存在
 */
export async function ensurePathExists(filePath: string, isDir?:boolean):Promise<boolean>{
    if(await pathExists(filePath))
        return true;
    return await createPath(filePath,isDir);
}

/**确保路径存在 不存在时创建 同步
 * @param {string} filePath - 待验证的路径
 * @returns {boolean} - 是否成功执行 创建或已存在
 */
export function ensurePathExistsSync(filePath: string, isDir?:boolean):boolean{
    if(pathExistsSync(filePath))
        return true;
    return createPathSync(filePath,isDir);
}

/**加载json文件 同步
 * Object (string)
 * @param {string} filePath - 文件路径
 * @returns {JObject}       - 加载完成的对象或空{}
 */
export function loadJSONFileSync(filePath: string): JObject
/**加载json文件 同步
 * Object (string)
 * @param {string} filePath - 文件路径
 * @param {T}      def      - 默认值
 * @returns {T}             - 加载完成的对象或默认值
 */
export function loadJSONFileSync<T extends JToken>(filePath: string,def: T): T
export function loadJSONFileSync<T extends JToken>(filePath: string,def?: T): T {
    if (path.extname(filePath) !== '.json') filePath += '.json';

    let str = "";

    // 判断文件路径是否存在
    if(pathExistsSync(filePath))
        str = fs.readFileSync(filePath, "utf-8");

    // 如果不存在则返回默认值
    if (str == "" || str == null){
        if(def!==undefined)
            return def;
        return {} as T;
    }
    return JSON.parse(str);
}

/**加载json文件 异步
 * Object (string)
 * @async
 * @param {string} filePath - 文件路径
 * @returns {Promise<JObject>} - 加载完成的对象或空{}
 */
export async function loadJSONFile(filePath: string): Promise<JObject>
/**加载json文件 异步
 * Object (string)
 * @async
 * @param {string} filePath - 文件路径
 * @param {T}      T        - 默认值
 * @returns {Promise<T>} - 加载完成的对象或默认值
 */
export async function loadJSONFile<T extends JToken>(filePath: string,def: T): Promise<T>
export async function loadJSONFile<T extends JToken>(filePath: string,def?: T): Promise<T> {
    if (path.extname(filePath) !== '.json') filePath += '.json';

    let str = "";

    // 判断文件路径是否存在
    if(await pathExists(filePath))
        str = await fs.promises.readFile(filePath, "utf-8");

    // 如果不存在则返回默认值
    if (str == "" || str == null){
        if(def!==undefined)
            return def;
        return {} as T;
    }
    return JSON.parse(str);
}

/**写入JSON文件
 * void (string,Object)
 * @async
 * @param {string} filePath - 文件路径
 * @param {JToken} token 	    - 所要写入的JToken
 * @returns {Promise<void>}
 */
export async function writeJSONFile(
    filePath: string,
    token: JToken
): Promise<void> {
    let str = stringifyJToken(token);
    if (path.extname(filePath) !== '.json') filePath += '.json';

    // 判断文件路径是否存在 不存在则创建
    if(!(await pathExists(filePath)))
        await createPath(filePath);

	// 写入文件
    try {
        await fs.promises.writeFile(filePath, str);
        SLogger.verbose(`${filePath} writeJSONFile 成功`);
    } catch (err) {
        SLogger.error(`${filePath} writeJSONFile 错误`,err);
    }
}

/**搜索路径符合正则表达式的文件
 * @param folder - 文件夹路径
 * @param traitRegex - 正则表达式
 * @returns {Record<string, string>} 文件名与路径的映射
 */
export function fileSearch(folder: string, traitRegex: string) {
    let outMap: Record<string, string> = {};
    let subFiles = fs.readdirSync(folder);
    let regex = new RegExp(traitRegex);
    for (let subFile of subFiles) {
        let subFilePath = path.join(folder, subFile);
        subFilePath = subFilePath.replace(/\\/g, "/");
        let stat = fs.lstatSync(subFilePath);

        //判断是否是文件夹，递归调用
        if (stat.isDirectory()) {
            let subMap = fileSearch(path.join(subFilePath, path.sep), traitRegex);
            for (let key in subMap) outMap[key] = subMap[key];
            continue;
        }
        if (regex.test(subFilePath)) outMap[subFile] = subFilePath;
    }
    return outMap;
}
}