import { FfmpegCommand, FfprobeData } from "fluent-ffmpeg";
import * as fluentFfmpeg from "fluent-ffmpeg";
import * as path from "path";
import * as fs from "fs";
import { SList, SStream } from "./UtilClass";
import { SLogger } from "./UtilLogger";

/**输入输出路径映射
 * 输入路径:输入路径
 */
export type IOMap = { [key: string]: string };

/**ffmpeg工具类
 */
class SFfmpegTool {
    /**静态构造函数
     */
    static init() {
        let ffmpegPath = process.env.FFMPEG_PATH;
        if(ffmpegPath!=null){
            let exepath = path.join(ffmpegPath,"ffmpeg.exe");
            SFfmpegTool.setFfmpegPath(exepath);
        }
    }
    /**设置ffmpeg路径
     */
    static setFfmpegPath(ffmpegPath: string) {
        fluentFfmpeg.setFfmpegPath(ffmpegPath);
    }
    /**获取音频文件的元数据
     * @param {string} inputWavPath - 输入音频文件路径
     * @returns {Promise<FfprobeData|null>} - 返回音频文件的元数据
     */
    static async getAudioMetaData(
        inputWavPath: string
    ): Promise<FfprobeData | null> {
        return new Promise((resolve, reject) => {
            fluentFfmpeg.ffprobe(inputWavPath, function (err, metadata) {
                if (err) {
                    SLogger.error("SFfmpegTool.getAudioMetaData 错误",err);
                    resolve(null);
                } else {
                    resolve(metadata);
                }
            });
        });
    }
    /**flac转ogg
     * @param {string} inputFlacFile - 输入flac文件路径
     * @param {string} outputOggPath - 输出ogg文件路径
     * @param {number} quality - 质量
     */
    static async flac2ogg(
        inputFlacFile: string,
        outputOggPath: string,
        quality: number = 10
    ): Promise<boolean> {
        let wavPath = path.join(
            path.dirname(inputFlacFile),
            `tmp_${path.basename(inputFlacFile, ".flac")}.wav`
        );
        await new Promise((resolve, reject) => {
            fluentFfmpeg(inputFlacFile)
                .audioCodec("pcm_s16le")
                .save(wavPath)
                .on("end", function () {
                    resolve(null);
                });
        });
        await SFfmpegTool.wav2ogg(wavPath, outputOggPath, quality);
        await new Promise((resolve, reject) => {
            fs.unlink(wavPath, function (err) {
                if (err) SLogger.error("SFfmpegTool.flac2ogg unlink 错误",err);
                resolve(null);
            });
        });
        return true;
    }
    /**wav转ogg
     * @param {string} inputWavPath - 输入wav文件路径
     * @param {string} outputOggPath - 输出ogg文件路径
     * @param {number} quality - 质量
     */
    static async wav2ogg(
        inputWavPath: string,
        outputOggPath: string,
        quality: number = 10
    ): Promise<boolean> {
        //.audioQuality(10)
        //.audioBitrate("192k")
        //.audioChannels(channels)
        //.noMetadata()
        return new Promise((resolve, reject) => {
            fluentFfmpeg(inputWavPath)
                .audioQuality(quality)
                .audioCodec("libvorbis")
                .save(outputOggPath)
                .on("end", () => resolve(true))
                .on("error", (err) => reject(err));
        });
    }
    /**剪切音频
     * @param {string} audioPath - 输入音频文件路径
     * @param {string} outPath - 输出音频文件路径
     * @param {number} start - 开始时间
     * @param {number} time - 时长
     */
    static async cutAudio(
        audioPath: string,
        outPath: string,
        start: number,
        time: number
    ): Promise<boolean> {
        return new Promise((resolve, reject) => {
            fluentFfmpeg(audioPath)
                .setStartTime(start)
                .setDuration(time)
                .save(outPath)
                .on("end", () => resolve(true))
                .on("error", (err) => reject(err));
        });
    }
    /**删除首尾静音
     * @param {string} inputWavPath - 输入wav文件路径
     * @param {string} outputWavPath - 输出wav文件路径
     * @param {number} threshold - 静音阈值/dB
     * @param {number} silence - 保留静音时长
     */
    static async trimSilence(
        inputWavPath: string,
        outputWavPath: string,
        threshold: number = -50,
        silence: number = 0.2
    ): Promise<boolean> {
        return new Promise((resolve, reject) => {
            fluentFfmpeg(inputWavPath)
                .audioFilters(
                    `silenceremove=start_periods=1:start_threshold=${threshold}dB:start_silence=${silence}`
                )
                .audioFilters("areverse")
                .audioFilters(
                    `silenceremove=start_periods=1:start_threshold=${threshold}dB:start_silence=${silence}`
                )
                .audioFilters("areverse")
                .save(outputWavPath)
                .on("end", () => resolve(true))
                .on("error", (err) => reject(err));
        });
    }
    /**重采样
     * @param {string} inputWavPath - 输入wav文件路径
     * @param {string} outputWavPath - 输出wav文件路径
     */
    static async resample(inputWavPath: string, outputWavPath: string, rate: number = 22050): Promise<boolean> {
        return new Promise((resolve, reject) => {
            fluentFfmpeg(inputWavPath)
                .audioFrequency(rate)
                .save(outputWavPath)
                .on("end", () => resolve(true))
                .on("error", (err) => reject(err));
        });
    }

    //多线程处理
    /**wav转ogg多线程
     * @param {IOMap} ioMap - 输入输出路径映射
     * @param {number} quality - 质量
     * @param {number} cpCount - 并发数
     */
    static async wav2oggMP(ioMap: IOMap, quality = 10, cpCount = 16) {
        await new SList(Object.entries(ioMap))
            .toSStream(cpCount)
            .map(async ([inPath, outPath]) => {
                SLogger.info("SFfmpegTool.wav2oggMP 正在处理:" + outPath);
                await SFfmpegTool.wav2ogg(inPath, outPath, quality);
            })
            .appendOperations();
    }
    /**flac转ogg多线程
     * @param {IOMap} ioMap - 输入输出路径映射
     * @param {number} quality - 质量
     * @param {number} cpCount - 并发数
     */
    static async flac2oggMP(
        ioMap: IOMap,
        quality: number = 10,
        cpCount: number = 16
    ) {
        await new SList(Object.entries(ioMap))
            .toSStream(cpCount)
            .map(async ([inPath, outPath]) => {
                SLogger.info("SFfmpegTool.flac2oggMP 正在处理:" + outPath);
                await SFfmpegTool.flac2ogg(inPath, outPath, quality);
            })
            .appendOperations();
    }
    /**删除静音多线程
     * @param {IOMap} ioMap - 输入输出路径映射
     * @param {number} threshold - 静音阈值/dB
     * @param {number} silence - 保留静音时长
     */
    static async trimSilenceMP(
        ioMap: IOMap,
        threshold: number = -50,
        silence: number = 0.2,
        cpCount: number = 16
    ) {
        await new SList(Object.entries(ioMap))
            .toSStream(cpCount)
            .map(async ([inPath, outPath]) => {
                SLogger.info("SFfmpegTool.trimSilenceMP 正在处理:" + outPath);
                await SFfmpegTool.trimSilence(inPath, outPath, threshold, silence);
            })
            .appendOperations();
    }

    /**重采样多线程
     * @param {IOMap} ioMap - 输入输出路径映射
     * @param {number} rate - 采样率
     * @param {number} cpCount - 并发数
     */
    static async resampleMP(ioMap: IOMap, rate: number = 22050, cpCount: number = 16) {
        await new SList(Object.entries(ioMap))
            .toSStream(cpCount)
            .map(async ([inPath, outPath]) => {
                SLogger.info("SFfmpegTool.resampleMP 正在处理:" + outPath);
                await SFfmpegTool.resample(inPath, outPath, rate);
            })
            .appendOperations();
    }
}
SFfmpegTool.init();


/**多线程任务分割器
 * @param {IOMap} iomap - 输入输出路径映射
 * @param {number} cpCount - 并发数
 */
function MPClip(iomap: IOMap, cpCount: number = 16) {
    let cpList: Array<IOMap> = [];
    for (let i = 0; i < cpCount; i++) cpList.push({});
    let cpCounter = 0;
    for (let key in iomap) {
        let cpIndex = cpCounter % cpCount;
        cpCounter++;
        cpList[cpIndex][key] = iomap[key];
    }
    return cpList;
}

type SFfmpegCmd = {
    name: string;
    opt: string | null;
};

/**ffmpeg流
 */
class SFfmpegStream {
    iomap;
    cmdList: Array<SFfmpegCmd> = [];
    constructor(iomap: IOMap) {
        this.iomap = iomap;
    }
    async save() {}

    //执行函数
    private async cmdAreverse() {}
}

export default SFfmpegTool;
export { SFfmpegTool };
