"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SFfmpegTool = void 0;
const fluentFfmpeg = require("fluent-ffmpeg");
const path = require("path");
const fs = require("fs");
const UtilClass_1 = require("./UtilClass");
const UtilLogger_1 = require("./UtilLogger");
/**ffmpeg工具类
 */
class SFfmpegTool {
    /**静态构造函数
     */
    static init() {
        let ffmpegPath = process.env.FFMPEG_PATH;
        if (ffmpegPath != null) {
            let exepath = path.join(ffmpegPath, "ffmpeg.exe");
            SFfmpegTool.setFfmpegPath(exepath);
        }
    }
    /**设置ffmpeg路径
     */
    static setFfmpegPath(ffmpegPath) {
        fluentFfmpeg.setFfmpegPath(ffmpegPath);
    }
    /**获取音频文件的元数据
     * @param {string} inputWavPath - 输入音频文件路径
     * @returns {Promise<FfprobeData|null>} - 返回音频文件的元数据
     */
    static async getAudioMetaData(inputWavPath) {
        return new Promise((resolve, reject) => {
            fluentFfmpeg.ffprobe(inputWavPath, function (err, metadata) {
                if (err) {
                    UtilLogger_1.SLogger.error("SFfmpegTool.getAudioMetaData 错误", err);
                    resolve(null);
                }
                else {
                    resolve(metadata);
                }
            });
        });
    }
    /**flac转ogg
     * @param {string} inputFlacFile - 输入flac文件路径
     * @param {string} outputOggPath - 输出ogg文件路径
     * @param {number} quality - 质量
     */
    static async flac2ogg(inputFlacFile, outputOggPath, quality = 10) {
        let wavPath = path.join(path.dirname(inputFlacFile), `tmp_${path.basename(inputFlacFile, ".flac")}.wav`);
        await new Promise((resolve, reject) => {
            fluentFfmpeg(inputFlacFile)
                .audioCodec("pcm_s16le")
                .save(wavPath)
                .on("end", function () {
                resolve(null);
            });
        });
        await SFfmpegTool.wav2ogg(wavPath, outputOggPath, quality);
        await new Promise((resolve, reject) => {
            fs.unlink(wavPath, function (err) {
                if (err)
                    UtilLogger_1.SLogger.error("SFfmpegTool.flac2ogg unlink 错误", err);
                resolve(null);
            });
        });
        return true;
    }
    /**wav转ogg
     * @param {string} inputWavPath - 输入wav文件路径
     * @param {string} outputOggPath - 输出ogg文件路径
     * @param {number} quality - 质量
     */
    static async wav2ogg(inputWavPath, outputOggPath, quality = 10) {
        //.audioQuality(10)
        //.audioBitrate("192k")
        //.audioChannels(channels)
        //.noMetadata()
        return new Promise((resolve, reject) => {
            fluentFfmpeg(inputWavPath)
                .audioQuality(quality)
                .audioCodec("libvorbis")
                .save(outputOggPath)
                .on("end", () => resolve(true))
                .on("error", (err) => reject(err));
        });
    }
    /**剪切音频
     * @param {string} audioPath - 输入音频文件路径
     * @param {string} outPath - 输出音频文件路径
     * @param {number} start - 开始时间
     * @param {number} time - 时长
     */
    static async cutAudio(audioPath, outPath, start, time) {
        return new Promise((resolve, reject) => {
            fluentFfmpeg(audioPath)
                .setStartTime(start)
                .setDuration(time)
                .save(outPath)
                .on("end", () => resolve(true))
                .on("error", (err) => reject(err));
        });
    }
    /**删除首尾静音
     * @param {string} inputWavPath - 输入wav文件路径
     * @param {string} outputWavPath - 输出wav文件路径
     * @param {number} threshold - 静音阈值/dB
     * @param {number} silence - 保留静音时长
     */
    static async trimSilence(inputWavPath, outputWavPath, threshold = -50, silence = 0.2) {
        return new Promise((resolve, reject) => {
            fluentFfmpeg(inputWavPath)
                .audioFilters(`silenceremove=start_periods=1:start_threshold=${threshold}dB:start_silence=${silence}`)
                .audioFilters("areverse")
                .audioFilters(`silenceremove=start_periods=1:start_threshold=${threshold}dB:start_silence=${silence}`)
                .audioFilters("areverse")
                .save(outputWavPath)
                .on("end", () => resolve(true))
                .on("error", (err) => reject(err));
        });
    }
    /**重采样
     * @param {string} inputWavPath - 输入wav文件路径
     * @param {string} outputWavPath - 输出wav文件路径
     */
    static async resample(inputWavPath, outputWavPath, rate = 22050) {
        return new Promise((resolve, reject) => {
            fluentFfmpeg(inputWavPath)
                .audioFrequency(rate)
                .save(outputWavPath)
                .on("end", () => resolve(true))
                .on("error", (err) => reject(err));
        });
    }
    //多线程处理
    /**wav转ogg多线程
     * @param {IOMap} ioMap - 输入输出路径映射
     * @param {number} quality - 质量
     * @param {number} cpCount - 并发数
     */
    static async wav2oggMP(ioMap, quality = 10, cpCount = 16) {
        await new UtilClass_1.SList(Object.entries(ioMap))
            .toSStream(cpCount)
            .map(async ([inPath, outPath]) => {
            UtilLogger_1.SLogger.info("SFfmpegTool.wav2oggMP 正在处理:" + outPath);
            await SFfmpegTool.wav2ogg(inPath, outPath, quality);
        })
            .appendOperations();
    }
    /**flac转ogg多线程
     * @param {IOMap} ioMap - 输入输出路径映射
     * @param {number} quality - 质量
     * @param {number} cpCount - 并发数
     */
    static async flac2oggMP(ioMap, quality = 10, cpCount = 16) {
        await new UtilClass_1.SList(Object.entries(ioMap))
            .toSStream(cpCount)
            .map(async ([inPath, outPath]) => {
            UtilLogger_1.SLogger.info("SFfmpegTool.flac2oggMP 正在处理:" + outPath);
            await SFfmpegTool.flac2ogg(inPath, outPath, quality);
        })
            .appendOperations();
    }
    /**删除静音多线程
     * @param {IOMap} ioMap - 输入输出路径映射
     * @param {number} threshold - 静音阈值/dB
     * @param {number} silence - 保留静音时长
     */
    static async trimSilenceMP(ioMap, threshold = -50, silence = 0.2, cpCount = 16) {
        await new UtilClass_1.SList(Object.entries(ioMap))
            .toSStream(cpCount)
            .map(async ([inPath, outPath]) => {
            UtilLogger_1.SLogger.info("SFfmpegTool.trimSilenceMP 正在处理:" + outPath);
            await SFfmpegTool.trimSilence(inPath, outPath, threshold, silence);
        })
            .appendOperations();
    }
    /**重采样多线程
     * @param {IOMap} ioMap - 输入输出路径映射
     * @param {number} rate - 采样率
     * @param {number} cpCount - 并发数
     */
    static async resampleMP(ioMap, rate = 22050, cpCount = 16) {
        await new UtilClass_1.SList(Object.entries(ioMap))
            .toSStream(cpCount)
            .map(async ([inPath, outPath]) => {
            UtilLogger_1.SLogger.info("SFfmpegTool.resampleMP 正在处理:" + outPath);
            await SFfmpegTool.resample(inPath, outPath, rate);
        })
            .appendOperations();
    }
}
exports.SFfmpegTool = SFfmpegTool;
SFfmpegTool.init();
/**多线程任务分割器
 * @param {IOMap} iomap - 输入输出路径映射
 * @param {number} cpCount - 并发数
 */
function MPClip(iomap, cpCount = 16) {
    let cpList = [];
    for (let i = 0; i < cpCount; i++)
        cpList.push({});
    let cpCounter = 0;
    for (let key in iomap) {
        let cpIndex = cpCounter % cpCount;
        cpCounter++;
        cpList[cpIndex][key] = iomap[key];
    }
    return cpList;
}
/**ffmpeg流
 */
class SFfmpegStream {
    iomap;
    cmdList = [];
    constructor(iomap) {
        this.iomap = iomap;
    }
    async save() { }
    //执行函数
    async cmdAreverse() { }
}
exports.default = SFfmpegTool;
