"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtilFT = void 0;
const fs = require("fs");
const path = require("path");
const UtilInterfaces_1 = require("./UtilInterfaces");
const UtilLogger_1 = require("./UtilLogger");
/**文件工具 */
var UtilFT;
(function (UtilFT) {
    /**验证路径 文件或文件夹 是否存在 异步
     * @async
     * @param {string} filePath - 待验证的路径
     * @returns {Promise<boolean>} - 是否存在
     */
    async function pathExists(filePath) {
        try {
            const stats = await fs.promises.stat(filePath);
            await fs.promises.access(filePath);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    UtilFT.pathExists = pathExists;
    /**验证路径 文件或文件夹 是否存在 同步
     * @param {string} filePath - 待验证的路径
     * @returns {boolean} - 是否存在
     */
    function pathExistsSync(filePath) {
        try {
            fs.accessSync(filePath);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    UtilFT.pathExistsSync = pathExistsSync;
    /**路径不存在时创建路径 以path.sep结尾时创建文件夹 异步
     * @async
     * @param {string} filePath - 待创建的路径
     * @param {boolean} isDir   - 强制创建一个文件夹
     * @returns {Promise<boolean>} - 是否成功创建
     */
    async function createPath(filePath, isDir) {
        if (isDir == true)
            filePath = path.join(filePath, path.sep);
        try {
            if (filePath.endsWith(path.sep)) {
                await fs.promises.mkdir(filePath, { recursive: true });
                return true;
            }
            await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
            await fs.promises.open(filePath, 'w');
            return true;
        }
        catch (e) {
            UtilLogger_1.SLogger.error("createPath 错误", e);
            return false;
        }
    }
    UtilFT.createPath = createPath;
    /**路径不存在时创建路径 以path.sep结尾时创建文件夹 同步
     * @param {string} filePath - 待创建的路径
     * @param {boolean} isDir   - 强制验证一个文件夹
     * @returns {boolean} - 是否成功创建
     */
    function createPathSync(filePath, isDir) {
        if (isDir == true)
            filePath = path.join(filePath, path.sep);
        try {
            if (filePath.endsWith(path.sep)) {
                fs.mkdirSync(filePath, { recursive: true });
                return true;
            }
            fs.mkdirSync(path.dirname(filePath), { recursive: true });
            fs.openSync(filePath, 'w');
            return true;
        }
        catch (e) {
            UtilLogger_1.SLogger.error("createPathSync 错误", e);
            return false;
        }
    }
    UtilFT.createPathSync = createPathSync;
    /**确保路径存在 不存在时创建 异步
     * @async
     * @param {string} filePath - 待验证的路径
     * @param {boolean} isDir   - 强制验证一个文件夹
     * @returns {Promise<boolean>} - 是否成功执行 创建或已存在
     */
    async function ensurePathExists(filePath, isDir) {
        if (await pathExists(filePath))
            return true;
        return await createPath(filePath, isDir);
    }
    UtilFT.ensurePathExists = ensurePathExists;
    /**确保路径存在 不存在时创建 同步
     * @param {string} filePath - 待验证的路径
     * @returns {boolean} - 是否成功执行 创建或已存在
     */
    function ensurePathExistsSync(filePath, isDir) {
        if (pathExistsSync(filePath))
            return true;
        return createPathSync(filePath, isDir);
    }
    UtilFT.ensurePathExistsSync = ensurePathExistsSync;
    function loadJSONFileSync(filePath, def) {
        if (path.extname(filePath) !== '.json')
            filePath += '.json';
        let str = "";
        // 判断文件路径是否存在
        if (pathExistsSync(filePath))
            str = fs.readFileSync(filePath, "utf-8");
        // 如果不存在则返回默认值
        if (str == "" || str == null) {
            if (def !== undefined)
                return def;
            return {};
        }
        return JSON.parse(str);
    }
    UtilFT.loadJSONFileSync = loadJSONFileSync;
    async function loadJSONFile(filePath, def) {
        if (path.extname(filePath) !== '.json')
            filePath += '.json';
        let str = "";
        // 判断文件路径是否存在
        if (await pathExists(filePath))
            str = await fs.promises.readFile(filePath, "utf-8");
        // 如果不存在则返回默认值
        if (str == "" || str == null) {
            if (def !== undefined)
                return def;
            return {};
        }
        return JSON.parse(str);
    }
    UtilFT.loadJSONFile = loadJSONFile;
    /**写入JSON文件
     * void (string,Object)
     * @async
     * @param {string} filePath - 文件路径
     * @param {JToken} token 	    - 所要写入的JToken
     * @returns {Promise<void>}
     */
    async function writeJSONFile(filePath, token) {
        let str = (0, UtilInterfaces_1.stringifyJToken)(token);
        if (path.extname(filePath) !== '.json')
            filePath += '.json';
        // 判断文件路径是否存在 不存在则创建
        if (!(await pathExists(filePath)))
            await createPath(filePath);
        // 写入文件
        try {
            await fs.promises.writeFile(filePath, str);
            UtilLogger_1.SLogger.verbose(`${filePath} writeJSONFile 成功`);
        }
        catch (err) {
            UtilLogger_1.SLogger.error(`${filePath} writeJSONFile 错误`, err);
        }
    }
    UtilFT.writeJSONFile = writeJSONFile;
    /**搜索路径符合正则表达式的文件
     * @param folder - 文件夹路径
     * @param traitRegex - 正则表达式
     * @returns {Record<string, string>} 文件名与路径的映射
     */
    function fileSearch(folder, traitRegex) {
        let outMap = {};
        let subFiles = fs.readdirSync(folder);
        let regex = new RegExp(traitRegex);
        for (let subFile of subFiles) {
            let subFilePath = path.join(folder, subFile);
            subFilePath = subFilePath.replace(/\\/g, "/");
            let stat = fs.lstatSync(subFilePath);
            //判断是否是文件夹，递归调用
            if (stat.isDirectory()) {
                let subMap = fileSearch(path.join(subFilePath, path.sep), traitRegex);
                for (let key in subMap)
                    outMap[key] = subMap[key];
                continue;
            }
            if (regex.test(subFilePath))
                outMap[subFile] = subFilePath;
        }
        return outMap;
    }
    UtilFT.fileSearch = fileSearch;
})(UtilFT = exports.UtilFT || (exports.UtilFT = {}));
