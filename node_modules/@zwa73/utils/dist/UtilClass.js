"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHashMap = exports.SEntry = exports.SIterator = exports.SStream = exports.SList = void 0;
class SList {
    _arr;
    constructor(obj) {
        if (typeof obj == "number")
            this._arr = new Array(obj);
        else if (Array.isArray(obj))
            this._arr = obj;
        else
            this._arr = [];
    }
    /**返回数组长度
     * @returns {number} - 长度
     */
    size() {
        return this._arr.length;
    }
    /**获取指定下标的元素
     * @param {number} index - 下标
     * @returns {T} - 目标元素
     */
    get(index) {
        return this._arr[index];
    }
    /**设置指定下标的元素
     * 返回自身 改变自身
     * @param   {number} index  - 下标
     * @param   {T} value       - 值
     * @returns {SList<T>}      - 自身
     */
    set(index, value) {
        this._arr[index] = value;
        return this;
    }
    /**连接两个数组
     * @param   {SList<T>} list - 目标数组
     * @returns {SList<T>}      - 新数组
     */
    concat(list) {
        return new SList(this._arr.concat(list._arr));
    }
    /**在数组末尾添加一个元素
     * 返回自身 改变自身
     * @param   {T} value   - 值
     * @returns {SList<T>}  - 自身
     */
    push(value) {
        this._arr.push(value);
        return this;
    }
    /**在数组末尾添加一个数组
     * 改变自身
     * @param   {SList<T>} list - 目标数组
     * @returns {SList<T>}      - 自身
     */
    pushList(list) {
        this._arr = this._arr.concat(list._arr);
        return this;
    }
    /**截取从起始点到结束点之前的一段数组
     * @param   {number} strat - 起始点
     * @param   {number} end   - 结束点
     * @returns {SList<T>}     - 新数组
     */
    slice(strat, end) {
        return new SList(this._arr.slice(strat, end));
    }
    /**翻转数组
     * 改变自身
     * @returns {SList<T>} - 自身
     */
    reverse() {
        this._arr.reverse();
        return this;
    }
    /**将SList转换为数组
     * @returns {Array<T>} - 数组
     */
    toArray() {
        return [].concat(this._arr);
    }
    /**将SList转换为SStream
     * @param   {number} concurrent - 并发数
     * @returns {SStream<T>} - 流
     */
    toSStream(concurrent) {
        return new SStream(this._arr, concurrent);
    }
    /**返回指定元素在数组中首次出现的位置
     * @param   {T} value   - 目标元素
     * @returns {number}    - 下标
     */
    indexOf(value) {
        return this._arr.indexOf(value);
    }
    /**返回指定元素在数组中最后一次出现的位置
     * @param   {T} value   - 目标元素
     * @returns {number}    - 下标
     */
    lastIndexOf(value) {
        return this._arr.lastIndexOf(value);
    }
    /**判断数组中是否包含指定元素
     * @param   {T} value    - 目标元素
     * @returns {boolean}    - 是否包含
     */
    contains(value) {
        return this._arr.includes(value);
    }
    /**获取迭代器
     * @returns {SIterator<T>} - 迭代器
     */
    iterator() {
        return new SIterator(this);
    }
    /**平分数组
     * @param   {number} count              - 份数
     * @param   {"average" | "chunk"} mode  - 模式 average:轮询平均分 chunk:切块均分
     * @returns {SList<SList<T>>}           - 新数组
     */
    divide(count, mode = "average") {
        if (count <= 0)
            return new SList();
        if (count == 1)
            return new SList([this.clone()]);
        let result = new SList();
        switch (mode) {
            //轮询平均分
            default:
            case "average":
                for (let i = 0; i < count; i++) {
                    let clist = new SList();
                    let size = this.size();
                    for (let j = i; j < size; j += count)
                        clist.push(this.get(j));
                    result.push(clist);
                }
                break;
            //切块均分
            case "chunk":
                let chunkSize = Math.ceil(this.size() / count);
                for (let i = 0; i < count; i++) {
                    let start = i * chunkSize;
                    let end = (i + 1) * chunkSize;
                    if (end > this.size())
                        end = this.size();
                    result.push(this.slice(start, end));
                }
                break;
        }
        return result;
    }
    /**从index开始删除count个元素，返回删除的元素数组
     * 改变自身
     * @param   {number} index  - 起始点
     * @param   {number} count  - 数量
     * @returns {SList<T>}      - 删除的元素数组
     */
    removeRange(index, count) {
        let narr = this._arr.splice(index, count);
        return new SList(narr);
    }
    /**删除对应下标下的元素，返回删除的元素
     * 改变自身
     * @param   {number} i   - 下标
     * @returns {T|null}     - 删除的元素
     */
    remove(i) {
        if (i >= 0 && i < this.size())
            return this._arr.splice(i, 1)[0];
        return null;
    }
    /**删除第一个匹配的项目，返回自身
     * 改变自身
     * @param   {T} obj     - 需删除目标
     * @returns {SList<T>}  - 自身
     */
    removeMember(obj) {
        let index = this.indexOf(obj);
        if (index > -1)
            this.remove(index);
        return this;
    }
    /**删除所有匹配的项目
     * 改变自身
     * @param {T} obj - 需删除目标
     * @returns {SList<T>} - 自身
     */
    removeAllMember(obj) {
        while (this.contains(obj))
            this.removeMember(obj);
        return this;
    }
    /**在这个下标对应的元素前添加一个元素
     * 改变自身
     * @param {number} index - 下标
     * @param {T} obj - 添加对象
     * @returns {SList<T>} - 自身
     */
    insert(index, obj) {
        this._arr.splice(index, 0, obj);
        return this;
    }
    /**在这个下标对应的元素前添加一组元素
     * 改变自身
     * @param {number} index - 下标
     * @param {SList<T>} obj - 添加对象
     * @returns {SList<T>} - 自身
     */
    insertRange(index, obj) {
        this._arr.splice(index, 0, ...obj._arr);
        return this;
    }
    /**删除并返回最后一个元素
     * 改变自身
     * @returns {T | null} - 最后一个元素
     */
    pop() {
        let val = this._arr.pop();
        return val == undefined ? null : val;
    }
    /**删除并返回第一个元素
     * 改变自身
     * @returns {T | null} - 第一个元素
     */
    shift() {
        let val = this._arr.shift();
        return val == undefined ? null : val;
    }
    /**克隆数组
     * @returns {SList<T>} - 新数组
     */
    clone() {
        return new SList([].concat(this._arr));
    }
    /**判断数组是否为空
     * @returns {boolean} - 是否为空
     */
    isEmpty() {
        return this.size() == 0;
    }
    /**删除数组中的重复元素
     * 改变自身
     * @returns {SList<T>} - 自身
     */
    removeDuplicates() {
        this._arr = Array.from(new Set(this._arr));
        return this;
    }
    /**交集
     * @param {SList<T>[]} lists - 数组列表
     * @returns {SList<T>} - 新数组
     */
    intersection(...lists) {
        let nlist = this.clone().removeDuplicates();
        for (let list of lists)
            nlist = list.filt((val) => nlist.contains(val));
        return nlist;
    }
    /**并集
     * @param {SList<T>[]} lists - 数组列表
     * @returns {SList<T>} - 新数组
     */
    union(...lists) {
        let nlist = this.clone().removeDuplicates();
        for (let list of lists) {
            list.each((val) => {
                if (!nlist.contains(val))
                    nlist.push(val);
            });
        }
        return nlist;
    }
    /**返回符合条件的成员组成的新数组
     * @param {FiltCallback<T>} func - 条件函数
     * @returns {SList<T>} - 新数组
     */
    filt(func) {
        let nlist = new SList(this.size());
        let length = 0;
        let it = this.iterator();
        while (it.hasNext()) {
            let tmpObj = it.next();
            if (func(tmpObj, it.currIndex(), this)) {
                nlist.set(length, tmpObj);
                length++;
            }
        }
        return nlist.slice(0, length);
    }
    /**遍历数组的每一个元素
     * @param {EachCallback<T>} func - 遍历函数 (value: T, index: number, list: SList<T>): void
     * @returns {SList<T>} - 自身
     */
    each(func) {
        let it = this.iterator();
        while (it.hasNext())
            func(it.next(), it.currIndex(), this);
        return this;
    }
    /**对数组的每一个元素进行加工，返回加工完成的成员组成的新数组
     * @param {MapCallback<T,O>} func - 加工函数 (value: T, index: number, list: SList<T>): O
     * @returns {SList<O>} - 新数组
     */
    map(func) {
        let nlist = new SList(this.size());
        let it = this.iterator();
        while (it.hasNext())
            nlist.set(it.nextIndex(), func(it.next(), it.currIndex(), this));
        return nlist;
    }
    /**对数组进行排序
     * 如函数返回值大于 0 则将 x 排在 y 后面，小于 0 则将 x 排在 y 前面
     * 改变自身
     * @param {SortCallback<T>} func - 排序函数 (a: T, b: T): number
     * @returns {SList<T>} - 自身
     */
    sort(func) {
        this._arr.sort(func);
        return this;
    }
    /**对数组进行统计 aggregate
     * 遍历数组，并将每次遍历的结果与下一次遍历的元素一起传入函数，最后返回最后一次遍历的结果
     * @param   {O} init                 - 初始值
     * @param   {AggrCallback<T,O>} func - 统计函数 (value: T, accumulator: U, index: number, list: SList<T>): U
     * @returns {O}                      - 统计结果
     */
    aggr(init, func) {
        let it = this.iterator();
        let tmpObj = init;
        while (it.hasNext())
            tmpObj = func(tmpObj, it.next(), it.currIndex(), this);
        return tmpObj;
    }
    /**对数组进行缩减
     * 遍历数组，并将每次遍历的结果与下一次遍历的元素一起传入函数，最后返回最后一次遍历的结果
     * @param   {ReduceCallback<T>} func  - 缩减函数 (previousValue: T, currentValue: T, currentIndex: number, array: SList<T>):T
     * @param   {T} init                  - 初始值
     * @returns {T}                       - 缩减结果
     */
    reduce(func, init) {
        if (this.size() === 0)
            return null;
        let it = this.iterator();
        let tmpObj = init === undefined ? it.next() : init;
        while (it.hasNext())
            tmpObj = func(tmpObj, it.next(), it.currIndex(), this);
        return tmpObj;
    }
    //重载TypeScript操作符
    [Symbol.iterator]() {
        let it = this.iterator();
        return {
            next() {
                if (it.hasNext()) {
                    return { value: it.next(), done: false };
                }
                else {
                    return { value: null, done: true };
                }
            },
        };
    }
}
exports.SList = SList;
class SStream {
    /**并发数*/
    _concurrent;
    /**原始列表*/
    _slist;
    /**加工函数列表*/
    _operation = [];
    constructor(slist, concurrent = 1) {
        if (slist instanceof SList)
            this._slist = slist;
        else if (Array.isArray(slist))
            this._slist = new SList(slist);
        else
            this._slist = new SList();
        this._concurrent = concurrent;
    }
    /**映射加工
     * @param {SStreamOperation<T,U>} operation - 加工函数
     * @returns {SStream<U>} - 新流
     */
    map(operation) {
        this._operation.push(operation);
        return this;
    }
    /**遍历
     * 返回自身
     * @param {SStreamOperation<T,void>} operation - 遍历函数
     * @returns {SStream<T>} - 自身
     */
    each(operation) {
        let opera = async (item) => {
            operation(item);
            return item;
        };
        this._operation.push(opera);
        return this;
    }
    //终结操作
    /**应用加工
     * @returns {SStream<T>} - 自身
     */
    async appendOperations() {
        if (this._operation.length == 0)
            return this;
        let nlist = new SList();
        let promiseList = [];
        //均分处理
        let sliceList = this._slist.divide(this._concurrent);
        for (let i = 0; i < this._concurrent; i++) {
            let subList = sliceList.get(i);
            if (!subList)
                continue;
            promiseList.push(new Promise(async () => {
                let result = new SList();
                for (let item of subList) {
                    if (!item)
                        continue;
                    for (let operation of this._operation)
                        item = await operation(item);
                    result.push(item);
                }
                nlist.set(i, result);
            }));
        }
        await Promise.all(promiseList);
        //拼接结果 轮询均分
        let result = new SList(this._slist.size());
        for (let i = 0; i < this._concurrent; i++) {
            let subList = nlist.get(i);
            if (!subList)
                continue;
            let subSize = subList.size();
            for (let j = 0; j < subSize; j++)
                result.set(i + j * this._concurrent, subList.get(j));
        }
        this._slist = result;
        this._operation = [];
        return this;
    }
    /**转换为SList
     * @returns {SList<T>} - 数组
     */
    async toSList() {
        await this.appendOperations();
        return this._slist;
    }
    /**转换为数组
     * @returns {Array<T>} - 数组
     */
    async toArray() {
        await this.appendOperations();
        return this._slist.toArray();
    }
}
exports.SStream = SStream;
class SIterator {
    _index = -1;
    _list;
    constructor(list) {
        this._list = list;
    }
    /**判断还有没有下一个元素
     * @returns {boolean} - 是否有下一个元素
     */
    hasNext() {
        return this._index < this.size() - 1 && this._index >= -1;
    }
    /**判断当前下标有无元素
     * @returns {boolean} - 是否有当前元素
     */
    hasCurr() {
        return this._index < this.size() && this._index >= 0;
    }
    /**判断还有没有上一个元素
     * @returns {boolean} - 是否有上一个元素
     */
    hasPre() {
        return this._index < this.size() + 1 && this._index >= 1;
    }
    /**返回下一个下标指向的数组内成员,然后下标自加1
     * @returns {T} - 下一个成员
     */
    next() {
        if (this.hasNext())
            return this._list.get(++this._index);
        else
            throw "一个 SIterator 迭代器的 next 函数出错,可能是在下标到底时还在尝试迭代";
    }
    /**返回上一个下标指向的数组内成员,然后下标自减1
     * @returns {T} - 上一个成员
     */
    pre() {
        if (this.hasPre())
            return this._list.get(--this._index);
        else
            throw "一个 SIterator 迭代器的 pre 函数出错,可能是在下标小于1时还在尝试迭代";
    }
    /**返回当前下标指向的数组内成员
     * @returns {T} - 当前成员
     */
    curr() {
        if (this.hasCurr())
            return this._list.get(this._index);
        else
            throw "一个 SIterator 迭代器的 curr 函数出错,可能是当前下标不包含元素/当前下标已越界";
    }
    /**返回遍历长度
     * @returns {number} - 遍历长度
     */
    size() {
        return this._list.size();
    }
    /**获取下个下标
     * @returns {number} - 下个下标
     */
    nextIndex() {
        return this._index + 1;
    }
    /**获取当前下标
     * @return {number} - 当前下标
     */
    currIndex() {
        return this._index;
    }
    /**获取上个下标
     * @returns {number} - 上个下标
     */
    preIndex() {
        return this._index - 1;
    }
    /**判断是否是最后一个
     * @returns {boolean} - 是否是最后一个
     */
    isLast() {
        return this._index >= this._list.size() - 1;
    }
    /**设置数组在迭代器当前下标中的内容
     * 返回自身
     * @param {T} val 要设置的内容
     * @returns {void}
     */
    set(val) {
        this._list.set(this._index, val);
        return this;
    }
    /**删除数组在当前下标的内容，然后将下标移至上一位，改变数组长度
     * @returns {T} - 被删除的内容
     */
    remove() {
        let tmp = this._list.get(this._index);
        this._list.remove(this._index);
        this._index--;
        return tmp;
    }
    /**在当前下标前插入元素，然后将下标移至原元素，即下一位，改变数组长度
     * 返回自身
     * @param {T} obj - 要插入的元素
     * @returns {SIterator<T>} - 自身
     */
    addPre(obj) {
        this._list.insert(this._index, obj);
        this._index++;
        return this;
    }
    /**在当前下标后插入元素，然后将下标移至新元素，即下一位，改变数组长度
     * 返回自身
     * @param {T} obj - 要插入的元素
     * @returns {SIterator<T>} - 自身
     */
    addNext(obj) {
        this._list.insert(this._index + 1, obj);
        this._index++;
        return this;
    }
}
exports.SIterator = SIterator;
class SEntry {
    _key;
    _value;
    constructor(key, value) {
        this._key = key;
        this._value = value;
    }
    getKey() {
        return this._key;
    }
    getValue() {
        return this._value;
    }
    //重载TypeScript操作符
    get key() {
        return this.getKey();
    }
    get value() {
        return this._value;
    }
}
exports.SEntry = SEntry;
class SHashMap {
    _map = new Map();
    /**构造函数
     * @param {Map<K, V>} [map] - 一个键值对集合
     */
    constructor(map) {
        if (map == null)
            return;
        let keys = map.keys();
        for (let key of keys) {
            let value = map.get(key);
            if (value != null)
                this.put(key, value);
        }
    }
    /**添加一个键值对
     * 返回自身
     * @param {SEntry<K, V>} entry - 键值对
     * @returns {SHashMap<K, V>} - 自身
     */
    putEntry(entry) {
        this._map.set(entry.getKey(), entry.getValue());
        return this;
    }
    /**获取指定键的值
     * @param {K} key - 键
     * @returns {V | undefined} - 值
     */
    get(key) {
        return this._map.get(key);
    }
    /**添加一个键值对
     * 返回自身
     * @param {K} key - 键
     * @param {V} value - 值
     * @returns {SHashMap<K, V>} - 自身
     */
    put(key, value) {
        this._map.set(key, value);
        return this;
    }
    /**判断是否存在指定键
     * @param {K} key - 键
     * @returns {boolean} - 是否存在
     */
    has(key) {
        return this._map.has(key);
    }
    /**获取所有键值对
     * @returns {SList<SEntry<K, V>>} - 键值对列表
     */
    entrys() {
        let list = new SList();
        for (const [key, value] of this._map)
            list.push(new SEntry(key, value));
        return list;
    }
    /**获取所有键
     * @returns {SList<K>} - 键列表
     */
    keys() {
        let list = new SList();
        let it = this._map.keys();
        for (let key of it)
            list.push(key);
        return list;
    }
    /**获取所有值
     * @returns {SList<V>} - 值列表
     */
    values() {
        let list = new SList();
        let it = this._map.values();
        for (let val of it)
            list.push(val);
        return list;
    }
    /**转换为entry数组，并获取迭代器
     * @returns {SIterator<SEntry<K, V>>} - 迭代器
     */
    iterator() {
        return this.entrys().iterator();
    }
    /**删除指定键的键值对
     * @param {K} key - 键
     * @returns {V | undefined} - 被删除的值
     */
    remove(key) {
        let out = this._map.get(key);
        this._map.delete(key);
        return out;
    }
    /**清空哈希表
     * @returns {SHashMap<K, V>} - 自身
     */
    clear() {
        this._map.clear();
        return this;
    }
    /**判断哈希表是否为空
     * @returns {boolean} - 是否为空
     */
    isEmpty() {
        return this.isEmpty();
    }
    /**判断是否存在指定值
     * @param {V} val - 值
     * @returns {boolean} - 是否存在
     */
    containsValue(val) {
        return this.values().contains(val);
    }
    /**判断是否存在指定键
     * @param {K} key - 键
     * @returns {boolean} - 是否存在
     */
    containsKey(key) {
        return this._map.has(key);
    }
    /**加载指定键的值，若不存在则添加默认值
     * 返回键值
     * @param {K} key - 键
     * @param {V} def - 默认值
     * @returns {V} - 值
     */
    load(key, def) {
        if (this.containsKey(key))
            return this.get(key);
        this.put(key, def);
        return def;
    }
    /**合并另一个哈希表，可选择是否覆盖已有键值对
     * @param {SHashMap<K, V>} nmap - 另一个哈希表
     * @param {boolean} [isCover=true] - 是否覆盖已有键值对，默认为 true
     * @returns {SHashMap<K, V>} - 自身
     */
    merge(nmap, isCover = true) {
        var it = nmap.iterator();
        while (it.hasNext()) {
            if (isCover)
                this.putEntry(it.next());
            else {
                var entry = it.next();
                if (!this.containsKey(entry.getKey()))
                    this.putEntry(entry);
            }
        }
        return this;
    }
    /**获取哈希表大小（键的数量）
     * @returns {number} - 大小
     */
    size() {
        return this._map.size;
    }
    /**对哈希表的每一个键值对进行加工，返回加工完成的键值对组成的新哈希表
     * @param {MapCallback<SEntry<K, V>, SEntry<OK, OV>>} func - 加工函数
     * @returns {SHashMap<OK, OV>} - 新哈希表
     */
    map(func) {
        let nmap = new SHashMap();
        this.entrys()
            .map(func)
            .each((val) => nmap.putEntry(val));
        return nmap;
    }
    /**返回符合条件的键值对组成的新哈希表
     * @param {FiltCallback<SEntry<K, V>>): boolean} func - 条件函数
     * @returns {SHashMap<K, V>} - 新哈希表
     */
    filt(func) {
        let nmap = new SHashMap();
        this.entrys()
            .filt(func)
            .each((val) => nmap.putEntry(val));
        return nmap;
    }
    /**遍历哈希表的每一个键值对
     * @param {EachCallback<SEntry<K, V>>} func - 遍历函数
     * @returns {SHashMap<K, V>} - 自身
     */
    each(func) {
        this.entrys().each(func);
        return this;
    }
    /**对哈希表进行统计
     * @param   {O} init                            - 初始值
     * @param   {AggrCallback<SEntry<K, V>,O>} func - 统计函数
     * @returns {O}                                 - 统计结果
     */
    aggr(init, func) {
        return this.entrys().aggr(init, func);
    }
    /**对哈希表进行缩减
     * @param {AggrCallback<SEntry<K, V>,V>} func   - 缩减函数
     * @param {V} init                              - 初始值
     * @returns {V}                                 - 缩减结果
     */
    reduce(func, init) {
        if (this.isEmpty()) {
            if (init === undefined)
                return null;
            return init;
        }
        let entries = this.entrys();
        let result;
        if (init === undefined) {
            result = entries.get(0).getValue();
            entries.shift();
        }
        else
            result = init;
        entries.each((val, index, list) => {
            result = func(result, val, index, list);
        });
        return result;
    }
    //重载TypeScript操作符
    [Symbol.iterator]() {
        let it = this.iterator();
        return {
            next() {
                if (it.hasNext()) {
                    return { value: it.next(), done: false };
                }
                else {
                    return { value: null, done: true };
                }
            },
        };
    }
}
exports.SHashMap = SHashMap;
class SKVC {
    stringMap = new SHashMap();
    constructor() { }
}
