/**遍历函数
 */
interface EachCallback<T> {
    /**
     * @param {T} value         - 值
     * @param {number} index    - 下标
     * @param {SList<T>} list   - 数组
     * @returns {void}
     */
    (value: T, index: number, list: SList<T>): void;
}
/**加工函数
 */
interface MapCallback<T, U> {
    /**
     * @param {T} value         - 值
     * @param {number} index    - 下标
     * @param {SList<T>} list   - 数组
     * @returns {U}             - 返回值
     */
    (value: T, index: number, list: SList<T>): U;
}
/**过滤函数
 */
interface FiltCallback<T> {
    /**
     * @param {T} value         - 值
     * @param {number} index    - 下标
     * @param {SList<T>} list   - 数组
     * @returns {boolean}       - 返回值
     */
    (value: T, index: number, list: SList<T>): boolean;
}
/**统计函数
 */
interface AggrCallback<T, U> {
    /**
     * @param {U} accumulator   - 累加器
     * @param {T} value         - 值
     * @param {number} index    - 下标
     * @param {SList<T>} list   - 数组
     * @returns {U}             - 返回值
     */
    (accumulator: U, value: T, index: number, list: SList<T>): U;
}
/**缩减函数
 */
interface ReduceCallback<T> {
    /**
     * @param {T} previousValue     - 上一个值/累加值
     * @param {T} currentValue      - 当前值
     * @param {number} currentIndex - 当前下标
     * @param {SList<T>} list       - 数组
     * @returns {T}                 - 返回值
     */
    (previousValue: T, currentValue: T, currentIndex: number, list: SList<T>): T;
}
/**排序函数
 */
interface SortCallback<T> {
    /**
     * @param {T} a         - 值a
     * @param {T} b         - 值b
     * @returns {number}    - 返回值
     */
    (a: T, b: T): number;
}
export declare class SList<T> {
    private _arr;
    /**建立0长度的SList */
    constructor();
    /**建立一个长度为 obj 的SList */
    constructor(obj: number);
    /**根据obj建立SList */
    constructor(obj: Array<T>);
    /**返回数组长度
     * @returns {number} - 长度
     */
    size(): number;
    /**获取指定下标的元素
     * @param {number} index - 下标
     * @returns {T} - 目标元素
     */
    get(index: number): T;
    /**设置指定下标的元素
     * 返回自身 改变自身
     * @param   {number} index  - 下标
     * @param   {T} value       - 值
     * @returns {SList<T>}      - 自身
     */
    set(index: number, value: T): SList<T>;
    /**连接两个数组
     * @param   {SList<T>} list - 目标数组
     * @returns {SList<T>}      - 新数组
     */
    concat(list: SList<T>): SList<T>;
    /**在数组末尾添加一个元素
     * 返回自身 改变自身
     * @param   {T} value   - 值
     * @returns {SList<T>}  - 自身
     */
    push(value: T): SList<T>;
    /**在数组末尾添加一个数组
     * 改变自身
     * @param   {SList<T>} list - 目标数组
     * @returns {SList<T>}      - 自身
     */
    pushList(list: SList<T>): this;
    /**截取从起始点到结束点之前的一段数组
     * @param   {number} strat - 起始点
     * @param   {number} end   - 结束点
     * @returns {SList<T>}     - 新数组
     */
    slice(strat: number, end: number): SList<T>;
    /**翻转数组
     * 改变自身
     * @returns {SList<T>} - 自身
     */
    reverse(): SList<T>;
    /**将SList转换为数组
     * @returns {Array<T>} - 数组
     */
    toArray(): Array<T>;
    /**将SList转换为SStream
     * @param   {number} concurrent - 并发数
     * @returns {SStream<T>} - 流
     */
    toSStream(concurrent?: number): SStream<T>;
    /**返回指定元素在数组中首次出现的位置
     * @param   {T} value   - 目标元素
     * @returns {number}    - 下标
     */
    indexOf(value: T): number;
    /**返回指定元素在数组中最后一次出现的位置
     * @param   {T} value   - 目标元素
     * @returns {number}    - 下标
     */
    lastIndexOf(value: T): number;
    /**判断数组中是否包含指定元素
     * @param   {T} value    - 目标元素
     * @returns {boolean}    - 是否包含
     */
    contains(value: T): boolean;
    /**获取迭代器
     * @returns {SIterator<T>} - 迭代器
     */
    iterator(): SIterator<T>;
    /**平分数组
     * @param   {number} count              - 份数
     * @param   {"average" | "chunk"} mode  - 模式 average:轮询平均分 chunk:切块均分
     * @returns {SList<SList<T>>}           - 新数组
     */
    divide(count: number, mode?: "average" | "chunk"): SList<SList<T>>;
    /**从index开始删除count个元素，返回删除的元素数组
     * 改变自身
     * @param   {number} index  - 起始点
     * @param   {number} count  - 数量
     * @returns {SList<T>}      - 删除的元素数组
     */
    removeRange(index: number, count: number): SList<T>;
    /**删除对应下标下的元素，返回删除的元素
     * 改变自身
     * @param   {number} i   - 下标
     * @returns {T|null}     - 删除的元素
     */
    remove(i: number): T | null;
    /**删除第一个匹配的项目，返回自身
     * 改变自身
     * @param   {T} obj     - 需删除目标
     * @returns {SList<T>}  - 自身
     */
    removeMember(obj: T): SList<T>;
    /**删除所有匹配的项目
     * 改变自身
     * @param {T} obj - 需删除目标
     * @returns {SList<T>} - 自身
     */
    removeAllMember(obj: T): SList<T>;
    /**在这个下标对应的元素前添加一个元素
     * 改变自身
     * @param {number} index - 下标
     * @param {T} obj - 添加对象
     * @returns {SList<T>} - 自身
     */
    insert(index: number, obj: T): SList<T>;
    /**在这个下标对应的元素前添加一组元素
     * 改变自身
     * @param {number} index - 下标
     * @param {SList<T>} obj - 添加对象
     * @returns {SList<T>} - 自身
     */
    insertRange(index: number, obj: SList<T>): SList<T>;
    /**删除并返回最后一个元素
     * 改变自身
     * @returns {T | null} - 最后一个元素
     */
    pop(): T | null;
    /**删除并返回第一个元素
     * 改变自身
     * @returns {T | null} - 第一个元素
     */
    shift(): T | null;
    /**克隆数组
     * @returns {SList<T>} - 新数组
     */
    clone(): SList<T>;
    /**判断数组是否为空
     * @returns {boolean} - 是否为空
     */
    isEmpty(): boolean;
    /**删除数组中的重复元素
     * 改变自身
     * @returns {SList<T>} - 自身
     */
    removeDuplicates(): SList<T>;
    /**交集
     * @param {SList<T>[]} lists - 数组列表
     * @returns {SList<T>} - 新数组
     */
    intersection(...lists: SList<T>[]): SList<T>;
    /**并集
     * @param {SList<T>[]} lists - 数组列表
     * @returns {SList<T>} - 新数组
     */
    union(...lists: SList<T>[]): SList<T>;
    /**返回符合条件的成员组成的新数组
     * @param {FiltCallback<T>} func - 条件函数
     * @returns {SList<T>} - 新数组
     */
    filt(func: FiltCallback<T>): SList<T>;
    /**遍历数组的每一个元素
     * @param {EachCallback<T>} func - 遍历函数 (value: T, index: number, list: SList<T>): void
     * @returns {SList<T>} - 自身
     */
    each(func: EachCallback<T>): SList<T>;
    /**对数组的每一个元素进行加工，返回加工完成的成员组成的新数组
     * @param {MapCallback<T,O>} func - 加工函数 (value: T, index: number, list: SList<T>): O
     * @returns {SList<O>} - 新数组
     */
    map<O>(func: MapCallback<T, O>): SList<O>;
    /**对数组进行排序
     * 如函数返回值大于 0 则将 x 排在 y 后面，小于 0 则将 x 排在 y 前面
     * 改变自身
     * @param {SortCallback<T>} func - 排序函数 (a: T, b: T): number
     * @returns {SList<T>} - 自身
     */
    sort(func: SortCallback<T>): SList<T>;
    /**对数组进行统计 aggregate
     * 遍历数组，并将每次遍历的结果与下一次遍历的元素一起传入函数，最后返回最后一次遍历的结果
     * @param   {O} init                 - 初始值
     * @param   {AggrCallback<T,O>} func - 统计函数 (value: T, accumulator: U, index: number, list: SList<T>): U
     * @returns {O}                      - 统计结果
     */
    aggr<O>(init: O, func: AggrCallback<T, O>): O;
    /**对数组进行缩减
     * 遍历数组，并将每次遍历的结果与下一次遍历的元素一起传入函数，最后返回最后一次遍历的结果
     * @param   {ReduceCallback<T>} func  - 缩减函数 (previousValue: T, currentValue: T, currentIndex: number, array: SList<T>):T
     * @param   {T} init                  - 初始值
     * @returns {T}                       - 缩减结果
     */
    reduce(func: ReduceCallback<T>, init?: T): T | null;
    [Symbol.iterator](): {
        next(): {
            value: T | null;
            done: boolean;
        };
    };
}
interface SStreamOperation<T, U> {
    (item: T): Promise<U>;
}
export declare class SStream<T> {
    /**并发数*/
    private _concurrent;
    /**原始列表*/
    private _slist;
    /**加工函数列表*/
    private _operation;
    constructor(slist: SList<T> | Array<T>, concurrent?: number);
    /**映射加工
     * @param {SStreamOperation<T,U>} operation - 加工函数
     * @returns {SStream<U>} - 新流
     */
    map<U>(operation: SStreamOperation<T, U>): SStream<U>;
    /**遍历
     * 返回自身
     * @param {SStreamOperation<T,void>} operation - 遍历函数
     * @returns {SStream<T>} - 自身
     */
    each(operation: SStreamOperation<T, void>): SStream<T>;
    /**应用加工
     * @returns {SStream<T>} - 自身
     */
    appendOperations(): Promise<SStream<T>>;
    /**转换为SList
     * @returns {SList<T>} - 数组
     */
    toSList(): Promise<SList<T>>;
    /**转换为数组
     * @returns {Array<T>} - 数组
     */
    toArray(): Promise<Array<T>>;
}
export declare class SIterator<T> {
    private _index;
    private _list;
    constructor(list: SList<T>);
    /**判断还有没有下一个元素
     * @returns {boolean} - 是否有下一个元素
     */
    hasNext(): boolean;
    /**判断当前下标有无元素
     * @returns {boolean} - 是否有当前元素
     */
    hasCurr(): boolean;
    /**判断还有没有上一个元素
     * @returns {boolean} - 是否有上一个元素
     */
    hasPre(): boolean;
    /**返回下一个下标指向的数组内成员,然后下标自加1
     * @returns {T} - 下一个成员
     */
    next(): T;
    /**返回上一个下标指向的数组内成员,然后下标自减1
     * @returns {T} - 上一个成员
     */
    pre(): T;
    /**返回当前下标指向的数组内成员
     * @returns {T} - 当前成员
     */
    curr(): T;
    /**返回遍历长度
     * @returns {number} - 遍历长度
     */
    size(): number;
    /**获取下个下标
     * @returns {number} - 下个下标
     */
    nextIndex(): number;
    /**获取当前下标
     * @return {number} - 当前下标
     */
    currIndex(): number;
    /**获取上个下标
     * @returns {number} - 上个下标
     */
    preIndex(): number;
    /**判断是否是最后一个
     * @returns {boolean} - 是否是最后一个
     */
    isLast(): boolean;
    /**设置数组在迭代器当前下标中的内容
     * 返回自身
     * @param {T} val 要设置的内容
     * @returns {void}
     */
    set(val: T): SIterator<T>;
    /**删除数组在当前下标的内容，然后将下标移至上一位，改变数组长度
     * @returns {T} - 被删除的内容
     */
    remove(): T;
    /**在当前下标前插入元素，然后将下标移至原元素，即下一位，改变数组长度
     * 返回自身
     * @param {T} obj - 要插入的元素
     * @returns {SIterator<T>} - 自身
     */
    addPre(obj: T): SIterator<T>;
    /**在当前下标后插入元素，然后将下标移至新元素，即下一位，改变数组长度
     * 返回自身
     * @param {T} obj - 要插入的元素
     * @returns {SIterator<T>} - 自身
     */
    addNext(obj: T): SIterator<T>;
}
export declare class SEntry<K, V> {
    private _key;
    private _value;
    constructor(key: K, value: V);
    getKey(): K;
    getValue(): V;
    get key(): K;
    get value(): V;
}
export declare class SHashMap<K, V> {
    private _map;
    /**构造函数
     * @param {Map<K, V>} [map] - 一个键值对集合
     */
    constructor(map?: Map<K, V>);
    /**添加一个键值对
     * 返回自身
     * @param {SEntry<K, V>} entry - 键值对
     * @returns {SHashMap<K, V>} - 自身
     */
    putEntry(entry: SEntry<K, V>): SHashMap<K, V>;
    /**获取指定键的值
     * @param {K} key - 键
     * @returns {V | undefined} - 值
     */
    get(key: K): V | undefined;
    /**添加一个键值对
     * 返回自身
     * @param {K} key - 键
     * @param {V} value - 值
     * @returns {SHashMap<K, V>} - 自身
     */
    put(key: K, value: V): SHashMap<K, V>;
    /**判断是否存在指定键
     * @param {K} key - 键
     * @returns {boolean} - 是否存在
     */
    has(key: K): boolean;
    /**获取所有键值对
     * @returns {SList<SEntry<K, V>>} - 键值对列表
     */
    entrys(): SList<SEntry<K, V>>;
    /**获取所有键
     * @returns {SList<K>} - 键列表
     */
    keys(): SList<K>;
    /**获取所有值
     * @returns {SList<V>} - 值列表
     */
    values(): SList<V>;
    /**转换为entry数组，并获取迭代器
     * @returns {SIterator<SEntry<K, V>>} - 迭代器
     */
    iterator(): SIterator<SEntry<K, V>>;
    /**删除指定键的键值对
     * @param {K} key - 键
     * @returns {V | undefined} - 被删除的值
     */
    remove(key: K): V | undefined;
    /**清空哈希表
     * @returns {SHashMap<K, V>} - 自身
     */
    clear(): SHashMap<K, V>;
    /**判断哈希表是否为空
     * @returns {boolean} - 是否为空
     */
    isEmpty(): boolean;
    /**判断是否存在指定值
     * @param {V} val - 值
     * @returns {boolean} - 是否存在
     */
    containsValue(val: V): boolean;
    /**判断是否存在指定键
     * @param {K} key - 键
     * @returns {boolean} - 是否存在
     */
    containsKey(key: K): boolean;
    /**加载指定键的值，若不存在则添加默认值
     * 返回键值
     * @param {K} key - 键
     * @param {V} def - 默认值
     * @returns {V} - 值
     */
    load(key: K, def: V): V;
    /**合并另一个哈希表，可选择是否覆盖已有键值对
     * @param {SHashMap<K, V>} nmap - 另一个哈希表
     * @param {boolean} [isCover=true] - 是否覆盖已有键值对，默认为 true
     * @returns {SHashMap<K, V>} - 自身
     */
    merge(nmap: SHashMap<K, V>, isCover?: boolean): SHashMap<K, V>;
    /**获取哈希表大小（键的数量）
     * @returns {number} - 大小
     */
    size(): number;
    /**对哈希表的每一个键值对进行加工，返回加工完成的键值对组成的新哈希表
     * @param {MapCallback<SEntry<K, V>, SEntry<OK, OV>>} func - 加工函数
     * @returns {SHashMap<OK, OV>} - 新哈希表
     */
    map<OK, OV>(func: MapCallback<SEntry<K, V>, SEntry<OK, OV>>): SHashMap<OK, OV>;
    /**返回符合条件的键值对组成的新哈希表
     * @param {FiltCallback<SEntry<K, V>>): boolean} func - 条件函数
     * @returns {SHashMap<K, V>} - 新哈希表
     */
    filt(func: FiltCallback<SEntry<K, V>>): SHashMap<K, V>;
    /**遍历哈希表的每一个键值对
     * @param {EachCallback<SEntry<K, V>>} func - 遍历函数
     * @returns {SHashMap<K, V>} - 自身
     */
    each(func: EachCallback<SEntry<K, V>>): SHashMap<K, V>;
    /**对哈希表进行统计
     * @param   {O} init                            - 初始值
     * @param   {AggrCallback<SEntry<K, V>,O>} func - 统计函数
     * @returns {O}                                 - 统计结果
     */
    aggr<O>(init: O, func: AggrCallback<SEntry<K, V>, O>): O;
    /**对哈希表进行缩减
     * @param {AggrCallback<SEntry<K, V>,V>} func   - 缩减函数
     * @param {V} init                              - 初始值
     * @returns {V}                                 - 缩减结果
     */
    reduce(func: AggrCallback<SEntry<K, V>, V>, init?: V): V | null;
    [Symbol.iterator](): {
        next(): {
            value: SEntry<K, V> | null;
            done: boolean;
        };
    };
}
export {};
