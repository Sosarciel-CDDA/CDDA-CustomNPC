"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SLogger = void 0;
const path = require("path");
const winston = require("winston");
const DailyRotateFile = require("winston-daily-rotate-file");
const util_1 = require("util");
const logLevels = {
    fatal: 0,
    error: 1,
    warn: 2,
    info: 3,
    http: 4,
    verbose: 5,
    debug: 6,
    silly: 7
};
const colorizer = winston.format.colorize();
colorizer.addColors({
    fatal: 'bold yellow redBG',
    error: 'bold yellow',
    warn: 'yellow',
    info: 'white',
    debug: 'bold cyan',
    silly: 'bold magenta'
});
class SLogger {
    /**获取一个Logger，如不存在则用默认参数创建
     * @param {string} name  - logger的名称 默认default
     * @returns {SLogger}    - 获取的logger
     */
    static getLogger(name = "default") {
        let out = SLogger.loggerTable[name];
        if (out == null) {
            SLogger.createLogger(name);
            out = SLogger.loggerTable[name];
        }
        return out;
    }
    /**创建Logger
     * @param {string} name             - logger的名称 默认default
     * @param {LogLevel} consoleLevel   - 输出到控制台的最低等级 默认info
     * @param {string} outFloder        - log的输出文件夹路径 如./log/
     * @param {LogLevel} fileLevel      - 输出到文件的最低等级   默认info
     * @returns {SLogger} - 创建完成的logger
     */
    static createLogger(name = "default", consoleLevel = "info", outFloder, fileLevel = "info") {
        const transports = [];
        if (outFloder != null) {
            const fileFormat = winston.format.combine(winston.format.timestamp({ format: 'HH:mm:ss' }), winston.format.printf((info) => {
                const level = info.level.toUpperCase();
                const message = info.message;
                //格式化
                //let format = `[${info.timestamp}] [${level}]: `
                //let space = " ".repeat(format.length);
                let messageList = message.split("\n");
                return `[${info.timestamp}] [${level.toUpperCase()}]: ${messageList.join("\n")}`;
            }));
            transports.push(new DailyRotateFile({
                filename: path.join(outFloder, 'log-%DATE%.txt'),
                datePattern: 'YYYY-MM-DD',
                level: fileLevel,
                format: fileFormat,
            }));
        }
        const consoleFormat = winston.format.combine(winston.format.timestamp({ format: 'HH:mm:ss' }), winston.format.printf((info) => {
            const level = info.level.toUpperCase();
            const message = info.message;
            const colorizedLevel = colorizer.colorize(info.level, level);
            //格式化
            //let format = `[${info.timestamp}] [${level}]: `
            //let space = " ".repeat(format.length);
            let messageList = message.split("\n");
            messageList[0] = colorizer.colorize(info.level, messageList[0]);
            for (let i = 1; i < messageList.length; i++)
                messageList[i] = colorizer.colorize(info.level, messageList[i]);
            return `[${info.timestamp}] [${colorizedLevel}]: ${messageList.join("\n")}`;
        }));
        transports.push(new winston.transports.Console({
            level: consoleLevel,
            format: consoleFormat,
        }));
        const logger = winston.createLogger({
            levels: logLevels,
            transports: transports,
        });
        const out = new SLogger();
        out._logger = logger;
        if (SLogger.loggerTable[name] != null) {
            let old = SLogger.loggerTable[name];
            old._logger.transports.forEach(tp => {
                if (tp.close != null)
                    tp.close();
            });
        }
        SLogger.loggerTable[name] = out;
        return out;
    }
    constructor() { }
    _logger = null;
    /**记录Logger的表 */
    static loggerTable = {};
    /**记录Logger的表 */
    static timeTable = {};
    //———————————————————— function ——————————————————————//
    /**产生一条对应等级的log 返回自身
     * @param {LogLevel} level      - log等级
     * @param {Array<any>} messages - log消息
     * @returns {SLogger} - 自身
     */
    log(level, ...messages) {
        level = level || "silly";
        let strMessages = [];
        //上一条是字符串字符串
        let preIsString = true;
        for (let message of messages) {
            let out;
            //非string类型
            if (typeof message !== "string") {
                out = `<${typeof message}> ${(0, util_1.inspect)(message)}`;
                preIsString = false;
            }
            else if (!preIsString) {
                //如果上一条不是字符串则需要添加<string>类型标记
                out = `<${typeof message}> ${(0, util_1.inspect)(message)}`;
                preIsString = true;
            }
            else {
                out = message;
            }
            strMessages.push(out);
        }
        let outMessage = strMessages.join("\n");
        this._logger.log(level, outMessage);
        return this;
    }
    /**产生一条fatal等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    fatal(...messages) {
        return this.log("fatal", ...messages);
        ;
    }
    /**产生一条error等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    error(...messages) {
        return this.log("error", ...messages);
        ;
    }
    /**产生一条warn等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    warn(...messages) {
        return this.log("warn", ...messages);
        ;
    }
    /**产生一条info等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    info(...messages) {
        return this.log("info", ...messages);
    }
    /**产生一条http等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    http(...messages) {
        return this.log("http", ...messages);
    }
    /**产生一条verbose等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger} - 自身
     */
    verbose(...messages) {
        return this.log("verbose", ...messages);
    }
    /**产生一条debug等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    debug(...messages) {
        return this.log("debug", ...messages);
    }
    /**产生一条silly等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    silly(...messages) {
        return this.log("silly", ...messages);
    }
    /**记录当前时间戳并存入表
     * @param {string} flag     - 记录的命名
     * @returns {HRTimeLog}     - 记录的时间
     */
    time(flag) {
        let hrtime = process.hrtime();
        SLogger.timeTable[flag] = hrtime;
        return hrtime;
    }
    /**根据之前记录的时间戳计算经过的时间 并输出log
     * @param {string}   flag       - 记录的命名
     * @param {LogLevel|null} level - log等级 ===null时不产生log
     * @returns {string|null}  - 格式化的时间字符串
     */
    timeEnd(flag, level = "info") {
        let start = SLogger.timeTable[flag];
        if (start == null) {
            this.warn("SLogger.timeEnd 错误 flag:" + flag + " 不存在");
            return null;
        }
        const timelen = process.hrtime(start);
        const totalMicroseconds = (timelen[0] * 1e9 + timelen[1]) / 1000;
        const microseconds = totalMicroseconds % 1000;
        const totalMilliseconds = totalMicroseconds / 1000;
        const milliseconds = Math.floor(totalMilliseconds % 1000);
        const totalSeconds = totalMilliseconds / 1000;
        const seconds = Math.floor(totalSeconds % 60);
        const totalMinutes = totalSeconds / 60;
        const minutes = Math.floor(totalMinutes % 60);
        const totalHours = totalMinutes / 60;
        const hours = Math.floor(totalHours % 24);
        const totalDay = totalHours / 24;
        const Days = Math.floor(totalDay);
        let out = '';
        if (totalSeconds > 60) {
            let result = '';
            let format = '';
            let acc = 0;
            const maxAcc = 3;
            let concat = function (num, sep, formatText, resultText) {
                let hasResult = result.length > 0;
                let need = (hasResult || num > 0) && (acc < maxAcc);
                if (need) {
                    if (result.length > 0)
                        result += sep;
                    if (format.length > 0)
                        format += sep;
                    result += resultText;
                    format += formatText;
                    acc++;
                }
            };
            concat(Days, ':', 'dd', `${Days.toString()}`);
            concat(hours, ':', 'HH', `${hours.toString().padStart(2, '0')}`);
            concat(minutes, ':', 'mm', `${minutes.toString().padStart(2, '0')}`);
            concat(seconds, ':', 'ss', `${seconds.toString().padStart(2, '0')}`);
            concat(milliseconds, '.', 'mmm', `${milliseconds.toString().padStart(3, '0')}`);
            //result = result.replace(/^(0(?![^0-9]))+/, '');
            result = result.replace(/^0+([0-9])/, "$1");
            out = `${result} (${format})`;
        }
        else if (totalMilliseconds > 1000) {
            out = `${totalSeconds.toFixed(3)}s`;
        }
        else {
            out = `${totalMilliseconds.toFixed(3)}ms`;
        }
        if (level !== null)
            this.log(level, flag + ": " + out);
        delete SLogger.timeTable[flag];
        return out;
    }
    //———————————————————— static ——————————————————————//
    /**名称为default的slogger实例 */
    static get defaultInstance() {
        if (SLogger.loggerTable.default == null)
            SLogger.createLogger();
        return SLogger.loggerTable.default;
    }
    /**让名称为default的logger 产生一条对应等级的log 返回自身
     * @param {LogLevel} level - log等级
     * @param {Array<any>} messages    - log消息
     * @returns {SLogger}      - 自身
     */
    static log(level, ...messages) {
        level = level || "silly";
        this.defaultInstance.log(level, ...messages);
        return this.defaultInstance;
    }
    /**让名称为default的logger 产生一条fatal等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    static fatal(...messages) {
        return this.log("fatal", ...messages);
        ;
    }
    /**让名称为default的logger 产生一条error等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    static error(...messages) {
        return this.log("error", ...messages);
        ;
    }
    /**让名称为default的logger 产生一条warn等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    static warn(...messages) {
        return this.log("warn", ...messages);
        ;
    }
    /**让名称为default的logger 产生一条info等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    static info(...messages) {
        return this.log("info", ...messages);
    }
    /**让名称为default的logger 产生一条http等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    static http(...messages) {
        return this.log("http", ...messages);
    }
    /**让名称为default的logger 产生一条verbose等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    static verbose(...messages) {
        return this.log("verbose", ...messages);
    }
    /**让名称为default的logger 产生一条debug等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    static debug(...messages) {
        return this.log("debug", ...messages);
    }
    /**让名称为default的logger 产生一条silly等级的log 返回自身
     * @param {Array<any>} messages - log消息
     * @returns {SLogger}   - 自身
     */
    static silly(...messages) {
        return this.log("silly", ...messages);
    }
    /**让名称为default的logger 记录当前时间戳并存入表
     * @param {string} flag     - 记录的命名
     * @returns {HRTimeLog}     - 记录的时间
     */
    static time(flag) {
        return this.defaultInstance.time(flag);
    }
    /**让名称为default的logger 根据之前记录的时间戳计算经过的时间 并输出log
     * @param {string}   flag  - 记录的命名
     * @param {LogLevel} level - log等级
     * @returns {void}
     */
    static timeEnd(flag, level = "info") {
        this.defaultInstance.timeEnd(flag, level);
    }
}
exports.SLogger = SLogger;
